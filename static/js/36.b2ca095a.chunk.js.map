{"version":3,"file":"static/js/36.b2ca095a.chunk.js","mappings":"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","sources":["Formula/api.tsx","Formula/internal.ts","Formula/optimization.ts","Formula/uiData.tsx"],"sourcesContent":["import Artifact from \"../Data/Artifacts/Artifact\";\r\nimport { ICachedArtifact, MainStatKey, SubstatKey } from \"../Types/artifact\";\r\nimport { ICachedCharacter } from \"../Types/character\";\r\nimport { allElementsWithPhy, ArtifactSetKey, CharacterKey } from \"../Types/consts\";\r\nimport { ICachedWeapon } from \"../Types/weapon\";\r\nimport { crawlObject, deepClone, layeredAssignment, objectKeyMap, objPathValue } from \"../Util/Util\";\r\nimport { input } from \"./index\";\r\nimport { Data, DisplaySub, Info, Input, NumNode, ReadNode, StrNode } from \"./type\";\r\nimport { NodeDisplay, UIData } from \"./uiData\";\r\nimport { constant, customRead, percent, resetData, setReadNodeKeys } from \"./utils\";\r\n\r\nconst asConst = true as const, pivot = true as const\r\n\r\nfunction inferInfoMut(data: Data, source?: Info[\"source\"]): Data {\r\n  crawlObject(data, [], (x: any) => x.operation, (x: NumNode, path: string[]) => {\r\n    if (path[0] === \"teamBuff\") {\r\n      path = path.slice(1)\r\n      if (!x.info) x.info = {}\r\n      x.info.isTeamBuff = true\r\n    }\r\n    const reference = objPathValue(input, path) as ReadNode<number> | undefined\r\n    if (reference)\r\n      x.info = { ...x.info, ...reference.info, prefix: undefined, source }\r\n    else if (path[0] !== \"tally\")\r\n      console.error(`Detect ${source} buff into non-existant key path ${path}`)\r\n  })\r\n\r\n  return data\r\n}\r\nfunction dataObjForArtifact(art: ICachedArtifact, mainStatAssumptionLevel: number = 0): Data {\r\n  const mainStatVal = Artifact.mainStatValue(art.mainStatKey, art.rarity, Math.max(Math.min(mainStatAssumptionLevel, art.rarity * 4), art.level))\r\n  const stats: [ArtifactSetKey | MainStatKey | SubstatKey, number][] = []\r\n  stats.push([art.mainStatKey, mainStatVal])\r\n  art.substats.forEach(({ key, accurateValue }) => key && stats.push([key, accurateValue]))\r\n  return {\r\n    art: {\r\n      ...Object.fromEntries(stats.map(([key, value]) =>\r\n        key.endsWith(\"_\") ? [key, percent(value / 100)] : [key, constant(value)])),\r\n      [art.slotKey]: {\r\n        id: constant(art.id), set: constant(art.setKey)\r\n      },\r\n    },\r\n    artSet: {\r\n      [art.setKey]: constant(1),\r\n    },\r\n  }\r\n}\r\nfunction dataObjForCharacter(char: ICachedCharacter): Data {\r\n  const result: Data = {\r\n    lvl: constant(char.level),\r\n    constellation: constant(char.constellation),\r\n    asc: constant(char.ascension),\r\n    infusion: {\r\n      team: char.infusionAura ? constant(char.infusionAura) : undefined,\r\n    },\r\n    premod: {\r\n      auto: constant(char.talent.auto),\r\n      skill: constant(char.talent.skill),\r\n      burst: constant(char.talent.burst),\r\n    },\r\n    enemy: {\r\n      ...objectKeyMap(allElementsWithPhy.map(ele => `${ele}_res_`), ele =>\r\n        percent((char.enemyOverride[`${ele.slice(0, -5)}_enemyRes_`] ?? 10) / 100)),\r\n      level: constant(char.enemyOverride.enemyLevel ?? char.level),\r\n    },\r\n    hit: {\r\n      hitMode: constant(char.hitMode),\r\n      reaction: constant(char.reactionMode),\r\n    },\r\n    customBonus: {},\r\n  }\r\n\r\n  for (const [key, value] of Object.entries(char.bonusStats))\r\n    result.customBonus![key] = key.endsWith('_') ? percent(value / 100) : constant(value)\r\n\r\n  if (char.enemyOverride.enemyDefRed_)\r\n    result.premod!.enemyDefRed_ = percent(char.enemyOverride.enemyDefRed_ / 100)\r\n  if (char.enemyOverride.enemyDefIgn_)\r\n    result.enemy!.defIgn = percent(char.enemyOverride.enemyDefIgn_ / 100)\r\n\r\n  crawlObject(char.conditional, [\"conditional\"], (x: any) => typeof x === \"string\", (x: string, keys: string[]) =>\r\n    layeredAssignment(result, keys, constant(x)))\r\n  return result\r\n}\r\nfunction dataObjForWeapon(weapon: ICachedWeapon): Data {\r\n  return {\r\n    weapon: {\r\n      id: constant(weapon.id),\r\n      lvl: constant(weapon.level),\r\n      asc: constant(weapon.ascension),\r\n      refinement: constant(weapon.refinement),\r\n      refineIndex: constant(weapon.refinement - 1)\r\n    },\r\n  }\r\n}\r\n/** These read nodes are very context-specific, and cannot be used anywhere else outside of `uiDataForTeam` */\r\nconst teamBuff = setReadNodeKeys(deepClone(input), [\"teamBuff\"]); // Use ONLY by dataObjForTeam\r\nfunction uiDataForTeam(teamData: Dict<CharacterKey, Data[]>, activeCharKey?: CharacterKey): Dict<CharacterKey, { target: UIData, buffs: Dict<CharacterKey, UIData> }> {\r\n  // May the goddess of wisdom bless any and all souls courageous\r\n  // enough to attempt for the understanding of this abomination.\r\n\r\n  const mergedData = Object.entries(teamData).map(([key, data]) => [key, { ...mergeData(data) }] as [CharacterKey, Data])\r\n  const result = Object.fromEntries(mergedData.map(([key]) =>\r\n    [key, { targetRef: {} as Data, buffs: [] as Data[], calcs: {} as Dict<CharacterKey, Data> }]))\r\n\r\n  const customReadNodes = {}\r\n  function getReadNode(path: readonly string[]): ReadNode<number> {\r\n    const base = (path[0] === \"teamBuff\")\r\n      ? objPathValue(teamBuff, path.slice(1))\r\n      : objPathValue(input, path)\r\n    if (base) return base\r\n    const custom = objPathValue(customReadNodes, path)\r\n    if (custom) return custom\r\n    const newNode = customRead(path)\r\n    if (path[0] === \"teamBuff\" && path[1] === \"tally\") newNode.accu = \"add\"\r\n    layeredAssignment(customReadNodes, path, newNode)\r\n    return newNode\r\n  }\r\n\r\n  Object.values(result).forEach(({ targetRef, buffs, calcs }) =>\r\n    mergedData.forEach(([sourceKey, source]) => {\r\n      const sourceBuff = source.teamBuff\r\n      // Create new copy of `calc` as we're mutating it later\r\n      const buff: Data = {}, calc: Data = deepClone({ teamBuff: sourceBuff })\r\n      buffs.push(buff)\r\n      calcs[sourceKey] = calc\r\n\r\n      // This construction creates a `Data` representing buff\r\n      // from `source` applying to `target`. It has 3 data:\r\n      // - `target` contains the reference for the final\r\n      //   data. It is not populated at this stage,\r\n      // - `calc` contains the calculation of the buffs,\r\n      // - `buff` contains read nodes that point to the\r\n      //   calculation in `calc`.\r\n\r\n      crawlObject(sourceBuff, [], (x: any) => x.operation, (x: NumNode | StrNode, path: string[]) => {\r\n        const info: Info = { ...objPathValue(input, path), source: sourceKey, prefix: undefined, asConst }\r\n        layeredAssignment(buff, path, resetData(getReadNode([\"teamBuff\", ...path]), calc, info))\r\n\r\n        crawlObject(x, [], (x: any) => x?.operation === \"read\", (x: ReadNode<number | string>) => {\r\n          if (x.path[0] === \"targetBuff\") return // Ignore teamBuff access\r\n\r\n          let readNode: ReadNode<number | string> | undefined, data: Data\r\n          if (x.path[0] === \"target\") { // Link the node to target data\r\n            readNode = getReadNode(x.path.slice(1))\r\n            data = targetRef\r\n          } else { // Link the node to source data\r\n            readNode = x\r\n            data = result[sourceKey].targetRef\r\n          }\r\n          layeredAssignment(calc, x.path, resetData(readNode, data))\r\n        })\r\n      })\r\n    })\r\n  )\r\n  mergedData.forEach(([targetKey, data]) => {\r\n    delete data.teamBuff\r\n    const { targetRef, buffs } = result[targetKey]\r\n    const buff = mergeData(buffs)\r\n    crawlObject(buff ?? {}, [], (x => x.operation), (x: NumNode, path: string[]) => {\r\n      // CAUTION\r\n      // This is safe only because `buff` is created using only `resetData`\r\n      // and `mergeData`. So every node here is created from either of the\r\n      // two functions, so the mutation wont't affect existing nodes.\r\n      x.info = { ...(objPathValue(teamBuff, path) as ReadNode<number> | undefined)?.info, prefix: \"teamBuff\", pivot }\r\n    })\r\n    Object.assign(targetRef, mergeData([data, buff, { teamBuff: buff, activeCharKey: constant(activeCharKey) }]))\r\n    targetRef[\"target\"] = targetRef\r\n  })\r\n  const origin = new UIData(undefined as any, undefined)\r\n  return Object.fromEntries(Object.entries(result).map(([key, value]) =>\r\n    [key, {\r\n      target: new UIData(value.targetRef, origin),\r\n      buffs: Object.fromEntries(Object.entries(value.calcs).map(([key, value]) =>\r\n        [key, new UIData(value, origin)]))\r\n    }]))\r\n}\r\nfunction mergeData(data: Data[]): Data {\r\n  function internal(data: any[], path: string[]): any {\r\n    if (data.length <= 1) return data[0]\r\n    if (data[0].operation) {\r\n      if (path[0] === \"teamBuff\") path = path.slice(1)\r\n      let { accu, type } = (objPathValue(input, path) as ReadNode<number> | ReadNode<string> | undefined) ?? {}\r\n      if (path[0] === \"tally\") accu = \"add\"\r\n      else if (accu === undefined) {\r\n        const errMsg = `Multiple entries when merging \\`unique\\` for key ${path}`\r\n        if (process.env.NODE_ENV === \"development\")\r\n          throw new Error(errMsg)\r\n        else\r\n          console.error(errMsg)\r\n\r\n        accu = type === \"number\" ? \"max\" : \"small\"\r\n      }\r\n      const result: NumNode | StrNode = { operation: accu, operands: data }\r\n      return result\r\n    } else {\r\n      return Object.fromEntries([...new Set(data.flatMap(x => Object.keys(x) as string[]))]\r\n        .map(key => [key, internal(data.map(x => x[key]).filter(x => x), [...path, key])]))\r\n    }\r\n  }\r\n  return data.length ? internal(data, []) : {}\r\n}\r\n\r\nfunction computeUIData(data: Data[]): UIData {\r\n  return new UIData(mergeData(data), undefined)\r\n}\r\ntype ComparedNodeDisplay<V = number> = NodeDisplay<V> & { diff: V }\r\nfunction compareTeamBuffUIData(uiData1: UIData, uiData2: UIData): Input<ComparedNodeDisplay, ComparedNodeDisplay<string>> {\r\n  return compareInternal(uiData1.getTeamBuff(), uiData2.getTeamBuff())\r\n}\r\nfunction compareDisplayUIData(uiData1: UIData, uiData2: UIData): { [key: string]: DisplaySub<ComparedNodeDisplay> } {\r\n  return compareInternal(uiData1.getDisplay(), uiData2.getDisplay())\r\n}\r\nfunction compareInternal(data1: any | undefined, data2: any | undefined): any {\r\n  if (data1?.operation || data2?.operation) {\r\n    const d1 = data1 as NodeDisplay | undefined\r\n    const d2 = data2 as NodeDisplay | undefined\r\n\r\n    if ((d1 && !d1.operation) || (d2 && !d2.operation))\r\n      throw new Error(\"Unmatched structure when comparing UIData\")\r\n\r\n    const result: ComparedNodeDisplay = {\r\n      info: {},\r\n      operation: true,\r\n      value: 0,\r\n      isEmpty: true,\r\n      unit: d2?.unit!,\r\n      formulas: [],\r\n      ...d1,\r\n      diff: (d2?.value ?? 0) - (d1?.value ?? 0)\r\n    }\r\n    if (typeof d1?.value === \"string\" || typeof d2?.value === \"string\") {\r\n      // In case `string` got involved, just use the other value\r\n      result.value = d1?.value ?? \"\" as any\r\n      result.diff = d2?.value ?? \"\" as any\r\n    }\r\n    return result\r\n  }\r\n\r\n  if (data1 || data2) {\r\n    const keys = new Set([...Object.keys(data1 ?? {}), ...Object.keys(data2 ?? {})])\r\n    return Object.fromEntries([...keys].map(key => [key, compareInternal(data1?.[key], data2?.[key])]))\r\n  }\r\n}\r\n\r\nexport type { NodeDisplay, UIData };\r\nexport {\r\n  dataObjForArtifact, dataObjForCharacter, dataObjForWeapon,\r\n  mergeData, computeUIData, inferInfoMut,\r\n  uiDataForTeam, compareTeamBuffUIData, compareDisplayUIData\r\n};\r\n","import { AnyNode, NumNode, StrNode } from \"./type\"\r\nimport { constant } from \"./utils\"\r\n\r\nexport function forEachNodes(formulas: (NumNode | StrNode)[], topDown: (formula: (NumNode | StrNode)) => void, bottomUp: (formula: (NumNode | StrNode)) => void): void {\r\n  const visiting = new Set<(NumNode | StrNode)>(), visited = new Set<(NumNode | StrNode)>()\r\n\r\n  function traverse(formula: (NumNode | StrNode)) {\r\n    if (visited.has(formula)) return\r\n\r\n    if (visiting.has(formula)) {\r\n      console.error(\"Found cyclical dependency during formula traversal\")\r\n      return\r\n    }\r\n    visiting.add(formula)\r\n\r\n    topDown(formula)\r\n\r\n    formula.operands.forEach(traverse)\r\n\r\n    bottomUp(formula)\r\n\r\n    visiting.delete(formula)\r\n    visited.add(formula)\r\n  }\r\n\r\n  formulas.forEach(traverse)\r\n}\r\n\r\nexport function mapFormulas(formulas: NumNode[], topDownMap: (formula: (NumNode | StrNode)) => (NumNode | StrNode), bottomUpMap: (current: (NumNode | StrNode), orig: (NumNode | StrNode)) => (NumNode | StrNode)): NumNode[]\r\nexport function mapFormulas(formulas: (NumNode | StrNode)[], topDownMap: (formula: (NumNode | StrNode)) => (NumNode | StrNode), bottomUpMap: (current: (NumNode | StrNode), orig: (NumNode | StrNode)) => (NumNode | StrNode)): (NumNode | StrNode)[] {\r\n  const visiting = new Set<(NumNode | StrNode)>()\r\n  const topDownMapped = new Map<(NumNode | StrNode), (NumNode | StrNode)>()\r\n  const bottomUpMapped = new Map<(NumNode | StrNode), (NumNode | StrNode)>()\r\n\r\n  function check(formula: (NumNode | StrNode)): (NumNode | StrNode) {\r\n    let topDown = topDownMapped.get(formula)\r\n    if (topDown) return topDown\r\n    topDown = topDownMap(formula)\r\n\r\n    let bottomUp = bottomUpMapped.get(topDown)\r\n    if (bottomUp) return bottomUp\r\n\r\n    if (visiting.has(topDown)) {\r\n      console.error(\"Found cyclical dependency during formula mapping\")\r\n      return constant(NaN)\r\n    }\r\n    visiting.add(topDown)\r\n\r\n    bottomUp = bottomUpMap(traverse(topDown), formula)\r\n\r\n    visiting.delete(topDown)\r\n\r\n    topDownMapped.set(formula, bottomUp)\r\n    bottomUpMapped.set(topDown, bottomUp)\r\n    return bottomUp\r\n  }\r\n\r\n  function traverse(formula: (NumNode | StrNode)): (NumNode | StrNode) {\r\n    const operands = formula.operands.map(check)\r\n    return arrayEqual(operands, formula.operands) ? formula : { ...formula, operands } as any\r\n  }\r\n\r\n  const result = formulas.map(check)\r\n  return arrayEqual(result, formulas) ? formulas : result\r\n}\r\n\r\nexport function mapContextualFormulas(formulas: NumNode[], baseContextId: number, topDownMap: (formula: AnyNode, contextId: ContextID) => [AnyNode, ContextID], bottomUpMap: (formula: AnyNode, orig: AnyNode, contextId: ContextID, origContextId: ContextID) => AnyNode): NumNode[]\r\nexport function mapContextualFormulas(formulas: AnyNode[], baseContextId: number, topDownMap: (formula: AnyNode, contextId: ContextID) => [AnyNode, ContextID], bottomUpMap: (formula: AnyNode, orig: AnyNode, contextId: ContextID, origContextId: ContextID) => AnyNode): AnyNode[] {\r\n  const visiting = new Set<AnyNode>()\r\n  const topDownByContext = new Map<ContextID, Map<AnyNode, AnyNode>>()\r\n  const bottomUpByContext = new Map<ContextID, Map<AnyNode, AnyNode>>()\r\n\r\n  function check(formula: AnyNode, parentContextId: ContextID): AnyNode {\r\n    let topDownMapping = topDownByContext.get(parentContextId)\r\n    if (!topDownMapping) {\r\n      topDownMapping = new Map()\r\n      topDownByContext.set(parentContextId, topDownMapping)\r\n    }\r\n\r\n    let topDown = topDownMapping.get(formula)\r\n    if (topDown) return topDown\r\n    let topDownContextId: number\r\n    [topDown, topDownContextId] = topDownMap(formula, parentContextId)\r\n\r\n    if (visiting.has(topDown)) {\r\n      console.error(\"Found cyclical dependency during formula mapping\")\r\n      return constant(NaN)\r\n    }\r\n\r\n    let bottomUpMapping = bottomUpByContext.get(topDownContextId)\r\n    if (!bottomUpMapping) {\r\n      bottomUpMapping = new Map()\r\n      bottomUpByContext.set(topDownContextId, bottomUpMapping)\r\n    }\r\n\r\n    let bottomUp = bottomUpMapping.get(topDown)\r\n    if (bottomUp) return bottomUp\r\n\r\n    visiting.add(topDown)\r\n    bottomUp = bottomUpMap(traverse(topDown, topDownContextId), formula, topDownContextId, parentContextId)\r\n    visiting.delete(topDown)\r\n\r\n    bottomUpMapping.set(topDown, bottomUp)\r\n    topDownMapping.set(formula, bottomUp)\r\n    return bottomUp\r\n  }\r\n\r\n  function traverse(formula: AnyNode, contextId: ContextID): AnyNode {\r\n    const operands = formula.operands.map(f => check(f, contextId))\r\n    return arrayEqual(operands, formula.operands) ? formula : { ...formula, operands }\r\n  }\r\n\r\n  const result = formulas.map(f => check(f, baseContextId))\r\n  return arrayEqual(formulas, result) ? formulas : result\r\n}\r\n\r\ntype ContextID = number\r\n\r\nfunction arrayEqual<T>(a: readonly T[] | undefined, b: readonly T[] | undefined): boolean {\r\n  if (a === undefined) return b === undefined\r\n  if (b === undefined) return false\r\n\r\n  return a.length === b.length && a.every((value, i) => value === b[i])\r\n}\r\n","import { assertUnreachable, objectKeyMap, objPathValue } from \"../Util/Util\"\r\nimport { forEachNodes, mapFormulas } from \"./internal\"\r\nimport { constant } from \"./utils\"\r\nimport { CommutativeMonoidOperation, ComputeNode, ConstantNode, Data, NumNode, Operation, ReadNode, StrNode, StrPrioNode } from \"./type\"\r\n\r\nconst allCommutativeMonoidOperations: StrictDict<CommutativeMonoidOperation, (_: number[]) => number> = {\r\n  min: (x: number[]): number => Math.min(...x),\r\n  max: (x: number[]): number => Math.max(...x),\r\n  add: (x: number[]): number => x.reduce((a, b) => a + b, 0),\r\n  mul: (x: number[]): number => x.reduce((a, b) => a * b, 1),\r\n}\r\nexport const allOperations: StrictDict<Operation | \"threshold\", (_: number[]) => number> = {\r\n  ...allCommutativeMonoidOperations,\r\n  res: ([res]: number[]): number => {\r\n    if (res < 0) return 1 - res / 2\r\n    else if (res >= 0.75) return 1 / (res * 4 + 1)\r\n    return 1 - res\r\n  },\r\n  sum_frac: (x: number[]): number => x[0] / x.reduce((a, b) => a + b),\r\n  threshold: ([value, threshold, pass, fail]: number[]): number => value >= threshold ? pass : fail,\r\n}\r\n\r\nconst commutativeMonoidOperationSet = new Set(Object.keys(allCommutativeMonoidOperations) as (NumNode[\"operation\"])[])\r\n\r\nexport function optimize(formulas: NumNode[], topLevelData: Data, shouldFold = (_formula: ReadNode<number | string | undefined>) => false): NumNode[] {\r\n  formulas = constantFold(formulas, topLevelData, shouldFold)\r\n  formulas = flatten(formulas)\r\n  formulas = deduplicate(formulas)\r\n  return formulas\r\n}\r\nexport function precompute(formulas: NumNode[], binding: (readNode: ReadNode<number>) => string): [compute: () => Float64Array, mapping: Dict<string, number>, buffer: Float64Array] {\r\n  // TODO: Use min-cut to minimize the size of interim array\r\n  type Reference = string | number | { ins: Reference[] }\r\n\r\n  const uniqueReadStrings = new Set<string>()\r\n  const uniqueNumbers = new Set<number>()\r\n  const mapping = new Map<NumNode, Reference>()\r\n\r\n  forEachNodes(formulas, _ => { }, f => {\r\n    const { operation } = f\r\n    switch (operation) {\r\n      case \"read\":\r\n        if (f.type !== \"number\" || (f.accu && f.accu !== \"add\"))\r\n          throw new Error(`Unsupported ${operation} node in precompute`)\r\n        const name = binding(f)\r\n        uniqueReadStrings.add(name)\r\n        mapping.set(f, name)\r\n        break\r\n      case \"add\": case \"min\": case \"max\": case \"mul\":\r\n      case \"threshold\": case \"res\": case \"sum_frac\":\r\n        mapping.set(f, { ins: f.operands.map(op => mapping.get(op)!) })\r\n        break\r\n      case \"const\":\r\n        if (typeof f.value !== \"number\")\r\n          throw new Error(\"Found string constant while precomputing\")\r\n        const value = f.value\r\n        uniqueNumbers.add(value)\r\n        mapping.set(f as ConstantNode<number>, value)\r\n        break\r\n      case \"match\": case \"lookup\": case \"subscript\":\r\n      case \"prio\": case \"small\":\r\n      case \"data\": throw new Error(`Unsupported ${operation} node in precompute`)\r\n      default: assertUnreachable(operation)\r\n    }\r\n  })\r\n\r\n  /**\r\n   * [ Outputs , Input , Constants, Deduplicated Compute ]\r\n   *\r\n   * Note that only Compute nodes are deduplicated. Outputs are arranged\r\n   * in the same order as formulas even when they are duplicated. Inputs\r\n   * are arranged in the same order as the read strings, even when they\r\n   * overlap with outputs. If an output is a constant or a compute node,\r\n   * only put the data in the output region.\r\n   */\r\n  const locations = new Map<NumNode | number | string, number>()\r\n\r\n  const readStrings = [...uniqueReadStrings], readOffset = formulas.length\r\n  const constValues = [...uniqueNumbers]\r\n  const computations: { out: number, ins: number[], op: (_: number[]) => number, buff: number[] }[] = []\r\n\r\n  formulas.forEach((f, i) => {\r\n    locations.set(f, i)\r\n    if (f.operation === \"const\") locations.set(f.value, i)\r\n  })\r\n  // After this line, if some outputs are also read node, `locations`\r\n  // will point to the one in the read node portion instead.\r\n  readStrings.forEach((str, i) => locations.set(str, i + formulas.length))\r\n  let offset = formulas.length + readStrings.length\r\n  constValues.forEach(value => locations.has(value) || locations.set(value, offset++))\r\n\r\n  // `locations` is stable from this point on. We now only append new values.\r\n  // There is no change to existing values.\r\n  //\r\n  // DO NOT read from `location` prior to this line.\r\n  mapping.forEach((ref, node) => {\r\n    if (typeof ref !== \"object\") {\r\n      locations.set(node, locations.get(ref)!)\r\n      return\r\n    }\r\n    if (!locations.has(node)) locations.set(node, offset++)\r\n    computations.push({\r\n      out: locations.get(node)!,\r\n      ins: node.operands.map(op => locations.get(op)!),\r\n      op: allOperations[node.operation],\r\n      buff: Array(node.operands.length).fill(0),\r\n    })\r\n  })\r\n\r\n  const buffer = new Float64Array(offset).fill(0)\r\n  uniqueNumbers.forEach(number => buffer[locations.get(number)!] = number)\r\n\r\n  // Copy target for when some outputs are duplicated\r\n  const copyList = formulas.map((node, i) => {\r\n    const src = locations.get(node)!\r\n    return src !== i ? [src, i] : undefined!\r\n  }).filter(x => x)\r\n  const copyFormula = copyList.length ? () => {\r\n    copyList.forEach(([src, dst]) => buffer[dst] = buffer[src])\r\n  } : undefined\r\n\r\n  return [() => {\r\n    computations.forEach(({ out, ins, op, buff }) => {\r\n      ins.forEach((i, j) => buff[j] = buffer[i])\r\n      buffer[out] = op(buff)\r\n    })\r\n    copyFormula?.()\r\n    return buffer\r\n  }, objectKeyMap(readStrings, (_, i) => readOffset + i), buffer]\r\n}\r\n\r\nfunction flatten(formulas: NumNode[]): NumNode[] {\r\n  return mapFormulas(formulas, f => f, _formula => {\r\n    let result = _formula\r\n    if (commutativeMonoidOperationSet.has(_formula.operation as any)) {\r\n      const formula = _formula as ComputeNode\r\n      const { operation } = formula\r\n\r\n      let flattened = false\r\n      const operands = formula.operands.flatMap(dep =>\r\n        (dep.operation === operation) ? (flattened = true, dep.operands) : [dep])\r\n      result = flattened ? { ...formula, operands } : formula\r\n    }\r\n\r\n    return result\r\n  })\r\n}\r\nfunction deduplicate(formulas: NumNode[]): NumNode[] {\r\n  function elementCounts<T>(array: readonly T[]): Map<T, number> {\r\n    const result = new Map<T, number>()\r\n    for (const value of array) result.set(value, (result.get(value) ?? 0) + 1)\r\n    return result\r\n  }\r\n  function arrayFromCounts<T>(counts: Map<T, number>): T[] {\r\n    return [...counts].flatMap(([dep, count]) => Array(count).fill(dep))\r\n  }\r\n\r\n  const wrap = {\r\n    common: {\r\n      counts: new Map<NumNode, number>(),\r\n      formulas: new Set<NumNode>(),\r\n      operation: \"add\" as Operation\r\n    }\r\n  }\r\n\r\n  while (true) {\r\n    let next: typeof wrap.common | undefined\r\n\r\n    const factored: ComputeNode = { operation: wrap.common.operation, operands: arrayFromCounts(wrap.common.counts) }\r\n\r\n    let candidatesByOperation = new Map<Operation, [ComputeNode, Map<NumNode, number>][]>()\r\n    for (const operation of Object.keys(allCommutativeMonoidOperations))\r\n      candidatesByOperation.set(operation, [])\r\n\r\n    formulas = mapFormulas(formulas, _formula => {\r\n      if (wrap.common.formulas.has(_formula as NumNode)) {\r\n        const formula = _formula as ComputeNode\r\n        const remainingCounts = new Map(wrap.common.counts)\r\n        const operands = formula.operands.filter(dep => {\r\n          const count = remainingCounts.get(dep)\r\n          if (count) {\r\n            remainingCounts.set(dep, count - 1)\r\n            return false\r\n          }\r\n          return true\r\n        })\r\n\r\n        if (!operands.length)\r\n          return factored\r\n        operands.push(factored)\r\n        return { ...formula, operands }\r\n      }\r\n      return _formula\r\n    }, _formula => {\r\n      if (!commutativeMonoidOperationSet.has(_formula.operation as any)) return _formula\r\n      const formula = _formula as ComputeNode\r\n\r\n      if (next) {\r\n        if (next.operation === formula.operation) {\r\n          const currentCounts = elementCounts(formula.operands), commonCounts = new Map<NumNode, number>()\r\n          const nextCounts = next.counts\r\n          let total = 0\r\n\r\n          for (const [dependency, currentCount] of currentCounts.entries()) {\r\n            const commonCount = Math.min(currentCount, nextCounts.get(dependency) ?? 0)\r\n            if (commonCount) {\r\n              commonCounts.set(dependency, commonCount)\r\n              total += commonCount\r\n            } else commonCounts.delete(dependency)\r\n          }\r\n          if (total > 1) {\r\n            next.counts = commonCounts\r\n            next.formulas.add(formula)\r\n          }\r\n        }\r\n      } else {\r\n        const candidates = candidatesByOperation.get(formula.operation)!\r\n        const counts = elementCounts(formula.operands)\r\n\r\n        for (const [candidate, candidateCounts] of candidates) {\r\n          let total = 0\r\n\r\n          const commonCounts = new Map<NumNode, number>()\r\n          for (const [dependency, candidateCount] of candidateCounts.entries()) {\r\n            const count = Math.min(candidateCount, counts.get(dependency) ?? 0)\r\n            if (count) {\r\n              commonCounts.set(dependency, count)\r\n              total += count\r\n            }\r\n          }\r\n          if (total > 1) {\r\n            next = {\r\n              counts: commonCounts,\r\n              formulas: new Set([formula, candidate]),\r\n              operation: formula.operation\r\n            }\r\n            candidatesByOperation.clear()\r\n            break\r\n          }\r\n        }\r\n        if (!next) candidates.push([formula, counts])\r\n      }\r\n\r\n      return formula\r\n    })\r\n\r\n    if (next) wrap.common = next\r\n    else break\r\n  }\r\n\r\n  return formulas\r\n}\r\n\r\n/**\r\n * Replace nodes with known values with appropriate constants,\r\n * avoiding removal of any nodes that pass `isFixed` predicate\r\n */\r\nexport function constantFold(formulas: NumNode[], topLevelData: Data, shouldFold = (_formula: ReadNode<number | string | undefined>) => false): NumNode[] {\r\n  type Context = { data: Data[], processed: Map<NumNode | StrNode, NumNode | StrNode> }\r\n  const origin: Context = { data: [], processed: new Map() }\r\n  const nextContextMap = new Map([[origin, new Map<Data, Context>()]])\r\n\r\n  function fold(formula: StrNode, context: Context): StrNode\r\n  function fold(formula: NumNode, context: Context): NumNode\r\n  function fold(formula: NumNode | StrNode, context: Context): NumNode | StrNode\r\n  function fold(formula: NumNode | StrNode, context: Context): NumNode | StrNode {\r\n    const old = context.processed.get(formula)\r\n    if (old) return old\r\n\r\n    const { operation } = formula\r\n    let result: NumNode | StrNode\r\n    switch (operation) {\r\n      case \"const\": return formula\r\n      case \"add\": case \"mul\": case \"max\": case \"min\":\r\n        const f = allOperations[operation]\r\n        const numericOperands: number[] = []\r\n        const formulaOperands: NumNode[] = formula.operands.filter(formula => {\r\n          const folded = fold(formula, context)\r\n          return (folded.operation === \"const\")\r\n            ? (numericOperands.push(folded.value), false)\r\n            : true\r\n        }).map(x => fold(x, context))\r\n        const numericValue = f(numericOperands)\r\n\r\n        // Fold degenerate cases. This may incorrectly compute NaN\r\n        // results, which shouldn't appear under expected usage.\r\n        // - zero\r\n        //   - 0 * ... = 0\r\n        // - infinity\r\n        //   - max(infinity, ...) = infinity\r\n        //   - infinity + ... = infinity\r\n        // - (-infinity)\r\n        //   - min(-infinity, ...) - infinity\r\n        //   - (-infinity) + ... = -infinity\r\n        // - NaN\r\n        //   - operation(NaN, ...) = NaN\r\n        if (!isFinite(numericValue)) {\r\n          if ((operation !== \"mul\") &&\r\n            (operation !== \"max\" || numericValue > 0) &&\r\n            (operation !== \"min\" || numericValue < 0)) {\r\n            result = constant(numericValue)\r\n            break\r\n          }\r\n        } else if (operation === \"mul\" && numericValue === 0) {\r\n          result = constant(numericValue)\r\n          break\r\n        }\r\n\r\n        if (numericValue !== f([])) // Skip vacuous values\r\n          formulaOperands.push(constant(numericValue))\r\n        if (formulaOperands.length <= 1) result = formulaOperands[0] ?? constant(f([]))\r\n        else result = { operation, operands: formulaOperands }\r\n        break\r\n      case \"res\": case \"sum_frac\": {\r\n        const operands = formula.operands.map(x => fold(x, context))\r\n        const f = allOperations[operation]\r\n        if (operands.every(x => x.operation === \"const\"))\r\n          result = constant(f(operands.map(x => (x as ConstantNode<number>).value)))\r\n        else result = { ...formula, operands }\r\n        break\r\n      }\r\n      case \"lookup\": {\r\n        const index = fold(formula.operands[0], context)\r\n        if (index.operation === \"const\") {\r\n          const selected = formula.table[index.value!] ?? formula.operands[1]\r\n          if (selected) {\r\n            result = fold(selected, context)\r\n            break\r\n          }\r\n        }\r\n        throw new Error(`Unsupported ${operation} node while folding`)\r\n      }\r\n      case \"prio\": {\r\n        const first = formula.operands.find(op => {\r\n          const folded = fold(op, context)\r\n          if (folded.operation !== \"const\")\r\n            throw new Error(`Unsupported ${operation} node while folding`)\r\n          return folded.value !== undefined\r\n        })\r\n        result = first ? fold(first, context) : constant(undefined)\r\n        break\r\n      }\r\n      case \"small\": {\r\n        let smallest = undefined as ConstantNode<string | undefined> | undefined\r\n        for (const operand of formula.operands) {\r\n          const folded = fold(operand, context)\r\n          if (folded.operation !== \"const\")\r\n            throw new Error(`Unsupported ${operation} node while folding`)\r\n          if (smallest?.value === undefined || (folded.value !== undefined && folded.value < smallest.value))\r\n            smallest = folded\r\n        }\r\n        result = smallest ?? constant(undefined)\r\n        break\r\n      }\r\n      case \"match\": {\r\n        const [v1, v2, match, unmatch] = formula.operands.map((x: NumNode | StrNode) => fold(x, context))\r\n        if (v1.operation !== \"const\" || v2.operation !== \"const\")\r\n          throw new Error(`Unsupported ${operation} node while folding`)\r\n        result = (v1.value === v2.value) ? match : unmatch\r\n        break\r\n      }\r\n      case \"threshold\": {\r\n        const [value, threshold, pass, fail] = formula.operands.map(x => fold(x, context))\r\n        if (value.operation === \"const\" && threshold.operation === \"const\")\r\n          result = value.value >= threshold.value ? pass : fail\r\n        else\r\n          result = { ...formula, operands: [value, threshold, pass, fail] }\r\n        break\r\n      }\r\n      case \"subscript\": {\r\n        const [index] = formula.operands.map(x => fold(x, context))\r\n        result = (index.operation === \"const\")\r\n          ? constant(formula.list[index.value])\r\n          : { ...formula, operands: [index] }\r\n        break\r\n      }\r\n      case \"read\": {\r\n        const operands = context.data\r\n          .map(x => objPathValue(x, formula.path) as (NumNode | StrNode))\r\n          .filter(x => x)\r\n\r\n        if (operands.length === 0) {\r\n          if (shouldFold(formula)) {\r\n            const { accu } = formula\r\n            if (accu === undefined || accu === \"small\")\r\n              result = formula.type === \"string\" ? constant(undefined) : constant(NaN)\r\n            else result = constant(allOperations[accu]([]))\r\n          } else result = formula\r\n        } else if (formula.accu === undefined || operands.length === 1)\r\n          result = fold(operands[operands.length - 1], context)\r\n        else\r\n          result = fold({ operation: formula.accu, operands } as ComputeNode | StrPrioNode, context)\r\n        break\r\n      }\r\n      case \"data\":\r\n        if (formula.reset) context = origin\r\n        const map = nextContextMap.get(context)!\r\n        let nextContext = map.get(formula.data)\r\n        if (!nextContext) {\r\n          nextContext = { data: [...context.data, formula.data], processed: new Map() }\r\n          nextContextMap.set(nextContext, new Map())\r\n          map.set(formula.data, nextContext)\r\n        }\r\n        result = fold(formula.operands[0], nextContext)\r\n        break\r\n      default: assertUnreachable(operation)\r\n    }\r\n\r\n    context.processed.set(formula, result)\r\n    return result\r\n  }\r\n\r\n  const context = { data: [topLevelData], processed: new Map() }\r\n  nextContextMap.set(context, new Map())\r\n  nextContextMap.get(origin)!.set(topLevelData, context)\r\n  return formulas.map(x => fold(x, context))\r\n}\r\n\r\nexport const testing = {\r\n  constantFold, flatten, deduplicate\r\n}\r\n","import { uiInput } from \".\"\r\nimport ColorText from \"../Components/ColoredText\"\r\nimport KeyMap, { Unit, valueString } from \"../KeyMap\"\r\nimport { assertUnreachable, crawlObject, layeredAssignment, objPathValue } from \"../Util/Util\"\r\nimport { allOperations } from \"./optimization\"\r\nimport { ComputeNode, Data, DataNode, DisplaySub, Info, LookupNode, MatchNode, NumNode, ReadNode, StrNode, SubscriptNode, ThresholdNode, UIInput } from \"./type\"\r\n\r\nconst shouldWrap = true\r\nexport interface NodeDisplay<V = number> {\r\n  /** Leave this here to make sure one can use `crawlObject` on hierarchy of `NodeDisplay` */\r\n  operation: true\r\n  info: Info\r\n  value: V\r\n  /** Whether the node fails the conditional test (`threshold_add`, `match`, etc.) or consists solely of empty nodes */\r\n  isEmpty: boolean\r\n  unit: Unit\r\n  formula?: Displayable\r\n  formulas: Displayable[]\r\n}\r\n\r\nexport class UIData {\r\n  origin: UIData\r\n  children = new Map<Data, UIData>()\r\n\r\n  data: Data[]\r\n  nodes = new Map<NumNode | StrNode, ContextNodeDisplay<number | string | undefined>>()\r\n  processed = new Map<NumNode | StrNode, NodeDisplay<number | string | undefined>>()\r\n\r\n  display: any = undefined\r\n  teamBuff: any = undefined\r\n\r\n  constructor(data: Data, parent: UIData | undefined) {\r\n    if (data === undefined) {\r\n      // Secret *origin* initializer\r\n      this.data = []\r\n      this.origin = this\r\n    } else {\r\n      if (!parent)\r\n        parent = new UIData(undefined as any, undefined)\r\n\r\n      this.data = [data, ...parent.data]\r\n      this.origin = parent.origin\r\n    }\r\n  }\r\n\r\n  getDisplay(): {\r\n    [key: string]: DisplaySub<NodeDisplay>\r\n  } {\r\n    if (!this.display) this.display = this.getAll([\"display\"])\r\n    return this.display\r\n  }\r\n  getTeamBuff(): UIInput<NodeDisplay, NodeDisplay<string>> {\r\n    if (!this.teamBuff) {\r\n      const calculated = this.getAll([\"teamBuff\"]), result = {} as any\r\n      // Convert `input` to `uiInput`\r\n      crawlObject(uiInput, [], (x: any) => x.operation, (x: ReadNode<number> | ReadNode<string>, path: string[]) => {\r\n        const node = objPathValue(calculated, x.path) as NumNode | undefined\r\n        if (node) layeredAssignment(result, path, node)\r\n      })\r\n      this.teamBuff = result\r\n    }\r\n    return this.teamBuff\r\n  }\r\n  getAll(prefix: string[]): any {\r\n    const result = {}\r\n    for (const data of this.data) {\r\n      crawlObject(objPathValue(data, prefix) ?? {}, [], (x: any) => x.operation,\r\n        (x: NumNode, key: string[]) => layeredAssignment(result, key, this.get(x)))\r\n    }\r\n    return result\r\n  }\r\n  get(node: NumNode): NodeDisplay\r\n  get(node: StrNode): NodeDisplay<string | undefined>\r\n  get(node: NumNode | StrNode): NodeDisplay<number | string | undefined>\r\n  get(node: NumNode | StrNode): NodeDisplay<number | string | undefined> {\r\n    if (node === undefined) {\r\n      console.trace(\"Please report this bug with this trace\")\r\n      return { info: {}, operation: true, value: undefined, isEmpty: true, unit: \"\", formulas: [] }\r\n    }\r\n    const old = this.processed.get(node)\r\n    if (old) return old\r\n\r\n    const result = computeNodeDisplay(this.computeNode(node))\r\n    this.processed.set(node, result)\r\n    // if (result.info.subVariant) console.log(result.info)\r\n    return result\r\n  }\r\n  private computeNode(node: NumNode): ContextNodeDisplay\r\n  private computeNode(node: StrNode): ContextNodeDisplay<string | undefined>\r\n  private computeNode(node: NumNode | StrNode): ContextNodeDisplay<number | string | undefined>\r\n  private computeNode(node: NumNode | StrNode): ContextNodeDisplay<number | string | undefined> {\r\n    const old = this.nodes.get(node)\r\n    if (old) return old\r\n\r\n    const { operation, info } = node\r\n    let result: ContextNodeDisplay<number | string | undefined>\r\n    switch (operation) {\r\n      case \"add\": case \"mul\": case \"min\": case \"max\":\r\n      case \"res\": case \"sum_frac\":\r\n        result = this._compute(node); break\r\n      case \"threshold\": result = this._threshold(node); break\r\n      case \"const\": result = this._constant(node.value); break\r\n      case \"subscript\": result = this._subscript(node); break\r\n      case \"read\": result = this._read(node); break\r\n      case \"data\": result = this._data(node); break\r\n      case \"match\": result = this._match(node); break\r\n      case \"lookup\": result = this._lookup(node); break\r\n      case \"prio\": result = this._prio(node.operands); break\r\n      case \"small\": result = this._small(node.operands); break\r\n      default: assertUnreachable(operation)\r\n    }\r\n\r\n    if (info) {\r\n      const { asConst } = info\r\n      result = { ...result }\r\n      result.info = mergeInfo(result.info, info)\r\n\r\n      // Pivot all keyed nodes for debugging\r\n      // if (info.key) result.info.pivot = true\r\n\r\n      if (asConst) {\r\n        delete result.formula\r\n        delete result.assignment\r\n        result.dependencies = new Set()\r\n      }\r\n      if (result.info.pivot || !result.formula)\r\n        result.mayNeedWrapping = false\r\n    }\r\n    createDisplay(result)\r\n\r\n    this.nodes.set(node, result)\r\n    return result\r\n  }\r\n\r\n  private prereadAll(path: readonly string[]): (NumNode | StrNode)[] {\r\n    return this.data.map(x => objPathValue(x, path) as NumNode | StrNode).filter(x => x)\r\n  }\r\n  private readFirst(path: readonly string[]): ContextNodeDisplay<number | string | undefined> | undefined {\r\n    const data = this.data.map(x => objPathValue(x, path) as NumNode | StrNode).find(x => x)\r\n    return data && this.computeNode(data)\r\n  }\r\n\r\n  private _prio(nodes: readonly StrNode[]): ContextNodeDisplay<string | undefined> {\r\n    const first = nodes.find(node => this.computeNode(node).value !== undefined)\r\n    return first ? this.computeNode(first) : illformedStr\r\n  }\r\n  private _small(nodes: readonly StrNode[]): ContextNodeDisplay<string | undefined> {\r\n    let smallest: ContextNodeDisplay<string | undefined> | undefined = undefined\r\n    for (const node of nodes) {\r\n      const candidate = this.computeNode(node)\r\n      if (smallest?.value === undefined || (candidate.value && candidate.value < smallest.value))\r\n        smallest = candidate\r\n    }\r\n    return smallest ?? illformedStr\r\n  }\r\n  private _read(node: ReadNode<number | string | undefined>): ContextNodeDisplay<number | string | undefined> {\r\n    const { path } = node\r\n    if (node.accu === undefined) {\r\n      return this.readFirst(path) ?? (node.type === \"string\" ? illformedStr : illformed)\r\n    } else {\r\n      const nodes = this.prereadAll(path)\r\n      if (nodes.length === 1) return this.computeNode(nodes[0])\r\n      return node.accu === \"small\"\r\n        ? this._small(nodes as StrNode[])\r\n        : this._accumulate(node.accu, nodes.map(x => this.computeNode(x)) as ContextNodeDisplay[])\r\n    }\r\n  }\r\n  private _lookup(node: LookupNode<NumNode | StrNode>): ContextNodeDisplay<number | string | undefined> {\r\n    const key = this.computeNode(node.operands[0]).value\r\n    const selected = node.table[key!] ?? node.operands[1]\r\n    if (!selected)\r\n      throw new Error(`Lookup Fail with key ${key}`)\r\n    return this.computeNode(selected)\r\n  }\r\n  private _match(node: MatchNode<StrNode | NumNode, StrNode | NumNode>): ContextNodeDisplay<number | string | undefined> {\r\n    const [v1Node, v2Node, matchNode, unmatchNode] = node.operands\r\n    const v1 = this.computeNode(v1Node), v2 = this.computeNode(v2Node)\r\n    const matching = v1.value === v2.value\r\n    let result = this.computeNode(matching ? matchNode : unmatchNode)\r\n    return ((matching && node.emptyOn === \"match\") || (!matching && node.emptyOn === \"unmatch\"))\r\n      ? makeEmpty(result.value) : result\r\n  }\r\n  private _threshold(node: ThresholdNode<NumNode | StrNode>): ContextNodeDisplay<number | string | undefined> {\r\n    const [valueNode, thresholdNode, pass, fail] = node.operands\r\n    const value = this.computeNode(valueNode), threshold = this.computeNode(thresholdNode)\r\n    const result = value.value >= threshold.value ? this.computeNode(pass) : this.computeNode(fail)\r\n    return (value.value >= threshold.value)\r\n      ? (node.emptyOn === \"ge\" ? makeEmpty(result.value) : result)\r\n      : (node.emptyOn === \"l\" ? makeEmpty(result.value) : result)\r\n  }\r\n  private _data(node: DataNode<NumNode | StrNode>): ContextNodeDisplay<number | string | undefined> {\r\n    let child = this.children.get(node.data)\r\n    if (!child) {\r\n      child = new UIData(node.data, node.reset ? this.origin : this)\r\n      this.children.set(node.data, child)\r\n    }\r\n    return child.computeNode(node.operands[0])\r\n  }\r\n  private _compute(node: ComputeNode): ContextNodeDisplay {\r\n    const { operation, operands } = node\r\n    return this._accumulate(operation, operands.map(x => this.computeNode(x)))\r\n  }\r\n  private _subscript(node: SubscriptNode<number>): ContextNodeDisplay {\r\n    const operand = this.computeNode(node.operands[0])\r\n    const value = node.list[operand.value] ?? NaN\r\n    return this._constant(value)\r\n  }\r\n  private _constant<V>(value: V): ContextNodeDisplay<V> {\r\n    return {\r\n      info: {}, value,\r\n      empty: false,\r\n      mayNeedWrapping: false,\r\n      dependencies: new Set(),\r\n    }\r\n  }\r\n  private _accumulate(operation: ComputeNode[\"operation\"], operands: ContextNodeDisplay[]): ContextNodeDisplay {\r\n    let info: Info | undefined\r\n    switch (operation) {\r\n      case \"add\": case \"mul\": case \"min\": case \"max\":\r\n      case \"res\": case \"sum_frac\":\r\n        info = accumulateInfo(operands)\r\n        break\r\n      default: assertUnreachable(operation)\r\n    }\r\n    switch (operation) {\r\n      case \"add\": case \"mul\": case \"min\": case \"max\":\r\n        const identity = allOperations[operation]([])\r\n        if (process.env.NODE_ENV !== \"development\")\r\n          operands = operands.filter(operand => operand.value !== identity)\r\n        if (!operands.length)\r\n          return Object.values(info).some(x => x) ? { ...this._constant(identity), info } : this._constant(identity)\r\n    }\r\n\r\n    let formula: { display: Displayable, dependencies: Displayable[] }\r\n    let mayNeedWrapping = false\r\n    switch (operation) {\r\n      case \"max\": formula = fStr`Max( ${{ operands }} )`; break\r\n      case \"min\": formula = fStr`Min( ${{ operands }} )`; break\r\n      case \"add\": formula = fStr`${{ operands, separator: ' + ' }}`; break\r\n      case \"mul\": formula = fStr`${{ operands, separator: ' * ', shouldWrap: operands.length > 1 }}`; break\r\n      case \"sum_frac\": formula = fStr`${{ operands: [operands[0]], shouldWrap }} / ( ${{ operands, separator: ' + ' }} )`; break\r\n      case \"res\": {\r\n        const base = operands[0].value\r\n        if (base < 0) {\r\n          formula = fStr`100% - ${{ operands, shouldWrap }} / 2`\r\n          mayNeedWrapping = true\r\n        }\r\n        else if (base >= 0.75) formula = fStr`100% / ( ${{ operands, shouldWrap }} * 4 + 100% )`\r\n        else {\r\n          formula = fStr`100% - ${{ operands, shouldWrap }}`\r\n          mayNeedWrapping = true\r\n        }\r\n        break\r\n      }\r\n      default: assertUnreachable(operation)\r\n    }\r\n    switch (operation) {\r\n      case \"add\": case \"mul\":\r\n        if (operands.length <= 1) mayNeedWrapping = operands[0]?.mayNeedWrapping ?? true\r\n        else if (operation === \"add\") mayNeedWrapping = true\r\n    }\r\n\r\n    const value = allOperations[operation](operands.map(x => x.value))\r\n    const dependencies = new Set([...operands.flatMap(x =>\r\n      x.info.pivot && x.assignment\r\n        ? [x.assignment, ...x.dependencies]\r\n        : [...x.dependencies])])\r\n    const result: ContextNodeDisplay = {\r\n      info, formula: formula.display,\r\n      empty: operands.every(x => x.empty),\r\n      value, mayNeedWrapping, dependencies,\r\n    }\r\n    return result\r\n  }\r\n}\r\ntype ContextNodeDisplayList = { operands: ContextNodeDisplay[], separator?: string, shouldWrap?: boolean }\r\nfunction fStr(strings: TemplateStringsArray, ...list: ContextNodeDisplayList[]): { display: Displayable, dependencies: Displayable[] } {\r\n  const dependencies = new Set<Displayable>()\r\n  const predisplay: Displayable[] = []\r\n\r\n  strings.forEach((string, i) => {\r\n    predisplay.push(string)\r\n\r\n    const key = list[i]\r\n    if (key) {\r\n      const { operands, shouldWrap, separator = \", \" } = key\r\n      operands.forEach((item, i, array) => {\r\n        let itemFormula: Displayable\r\n        if (!item.info.pivot && item.formula) itemFormula = item.formula\r\n        else itemFormula = createFormulaComponent(item)\r\n\r\n        if (shouldWrap && item.mayNeedWrapping) {\r\n          predisplay.push(\"( \")\r\n          predisplay.push(itemFormula)\r\n          predisplay.push(\" )\")\r\n        } else {\r\n          predisplay.push(itemFormula)\r\n        }\r\n        if (i + 1 < array.length) predisplay.push(separator)\r\n        item.dependencies.forEach(x => dependencies.add(x))\r\n      })\r\n    }\r\n  })\r\n  return { display: mergeFormulaComponents(predisplay), dependencies: [...dependencies] }\r\n}\r\nfunction accumulateInfo<V>(operands: ContextNodeDisplay<V>[]): Info {\r\n  function score(variant: Required<Info>[\"variant\"]) {\r\n    switch (variant) {\r\n      case \"overloaded\": case \"shattered\": case \"electrocharged\": case \"superconduct\":\r\n      case \"vaporize\": case \"swirl\": case \"melt\": case \"success\": return 2\r\n      case \"anemo\": case \"cryo\": case \"hydro\": case \"pyro\": case \"electro\": case \"geo\": return 1\r\n      case \"physical\": return 0\r\n      default: assertUnreachable(variant)\r\n    }\r\n  }\r\n  const variants = new Set(operands.flatMap(x => [x.info.variant!, x.info.subVariant!]))\r\n  variants.delete(undefined!);\r\n  const sorted = [...variants].sort((a, b) => score(a) - score(b)), result: Info = {}\r\n  if (sorted.length) result.variant = sorted.pop()\r\n  if (sorted.length) result.subVariant = sorted.pop()\r\n  else result.subVariant = result.variant\r\n  return result\r\n}\r\nfunction computeNodeDisplay<V>(node: ContextNodeDisplay<V>): NodeDisplay<V> {\r\n  const { info, dependencies, value, formula, assignment, empty } = node\r\n  return {\r\n    operation: true,\r\n    info,\r\n    value,\r\n    isEmpty: empty,\r\n    unit: KeyMap.unit(info.key),\r\n    formula, formulas: [...(assignment ? [assignment] : []), ...dependencies]\r\n  }\r\n}\r\n\r\n//* Comment/uncomment this line to toggle between string formulas and JSX formulas\r\nfunction createDisplay(node: ContextNodeDisplay<number | string | undefined>) {\r\n  const { info, value, formula } = node\r\n  const { key, prefix, source, variant, fixed } = info\r\n  if (typeof value !== \"number\") return\r\n  node.valueDisplay = <ColorText color=\"info\">{valueString(value, KeyMap.unit(key), fixed)}</ColorText>\r\n  if (key && key !== '_') {\r\n    const prefixDisplay = (prefix && !source) ? <>{KeyMap.getPrefixStr(prefix)} </> : <></>\r\n    // TODO: Convert `source` key to actual name\r\n    const sourceDisplay = source ? <ColorText color=\"secondary\"> ({source})</ColorText> : null\r\n    node.name = <><ColorText color={variant}>{prefixDisplay}{KeyMap.get(key!)}</ColorText>{sourceDisplay}</>\r\n\r\n    if (formula)\r\n      node.assignment = <div id=\"formula\">{node.name} {node.valueDisplay} = {formula}</div>\r\n  }\r\n}\r\nfunction createFormulaComponent(node: ContextNodeDisplay): Displayable {\r\n  const { name, valueDisplay } = node\r\n  //TODO: change formula size in the formula display element instead\r\n  return name ? <><span style={{ fontSize: \"85%\" }}>{name}</span> {valueDisplay}</> : valueDisplay!\r\n}\r\nfunction mergeFormulaComponents(components: Displayable[]): Displayable {\r\n  return <>{components.map((x, i) => <span key={i}>{x}</span>)}</>\r\n}\r\n/*/\r\nfunction createDisplay(node: ContextNodeDisplay<number | string | undefined>) {\r\n  const { info, value, formula } = node\r\n  const { key, prefix, source, fixed } = info\r\n  if (typeof value !== \"number\") return\r\n  node.valueDisplay = valueString(value, KeyMap.unit(key), fixed)\r\n  if (key && key !== '_') {\r\n    const prefixDisplay = (prefix && !source) ? `${KeyMap.getPrefixStr(prefix)} ` : \"\"\r\n    // TODO: Convert `source` key to actual name\r\n    const sourceDisplay = source ? ` ${source}` : \"\"\r\n    node.name = `${prefixDisplay}${KeyMap.getStr(key!)}${sourceDisplay}`\r\n\r\n    if (formula)\r\n      node.assignment = `${node.name} ${node.valueDisplay} = ${formula}`\r\n  }\r\n}\r\nfunction createFormulaComponent(node: ContextNodeDisplay): Displayable {\r\n  const { name, valueDisplay } = node\r\n  return name ? `${name} ${valueDisplay}` : valueDisplay!\r\n}\r\nfunction mergeFormulaComponents(components: Displayable[]): Displayable {\r\n  return (components as string[]).join(\"\")\r\n}\r\n//*/\r\n\r\nfunction mergeInfo(base: Info, override: Info): Info {\r\n  const result = { ...base }\r\n  for (const [key, value] of Object.entries(override))\r\n    if (value) result[key] = value as any\r\n  return result\r\n}\r\n\r\ninterface ContextNodeDisplay<V = number> {\r\n  info: Info\r\n  empty: boolean\r\n  value: V\r\n\r\n  dependencies: Set<Displayable>\r\n\r\n  mayNeedWrapping: boolean // Whether this formula should be parenthesized when it is a part of multiplications/divisions and subtractions' subtrahends\r\n\r\n  // Don't set these manually outside of `UIData.computeNode`\r\n  name?: Displayable\r\n  valueDisplay?: Displayable\r\n  formula?: Displayable\r\n  assignment?: Displayable\r\n}\r\n\r\nconst illformed: ContextNodeDisplay = {\r\n  info: { pivot: true },\r\n  value: NaN,\r\n  empty: false,\r\n  dependencies: new Set(),\r\n  mayNeedWrapping: false\r\n}\r\nconst illformedStr: ContextNodeDisplay<string | undefined> = {\r\n  info: { pivot: true },\r\n  value: undefined,\r\n  empty: false,\r\n  dependencies: new Set(),\r\n  mayNeedWrapping: false\r\n}\r\nfunction makeEmpty(emptyValue: number): ContextNodeDisplay<number>\r\nfunction makeEmpty(emptyValue: string | undefined): ContextNodeDisplay<string | undefined>\r\nfunction makeEmpty(emptyValue: number | string | undefined): ContextNodeDisplay<number | string | undefined>\r\nfunction makeEmpty(emptyValue: number | string | undefined): ContextNodeDisplay<number | string | undefined> {\r\n  return {\r\n    info: {}, value: emptyValue, empty: true, dependencies: new Set(), mayNeedWrapping: false\r\n  }\r\n}\r\n"],"names":["inferInfoMut","data","source","crawlObject","x","operation","path","slice","info","isTeamBuff","reference","objPathValue","input","prefix","undefined","console","error","dataObjForArtifact","art","mainStatAssumptionLevel","mainStatVal","Artifact","mainStatKey","rarity","Math","max","min","level","stats","push","substats","forEach","key","accurateValue","Object","fromEntries","map","value","endsWith","percent","constant","slotKey","id","set","setKey","artSet","dataObjForCharacter","char","result","lvl","constellation","asc","ascension","infusion","team","infusionAura","premod","auto","talent","skill","burst","enemy","objectKeyMap","allElementsWithPhy","ele","enemyOverride","enemyLevel","hit","hitMode","reaction","reactionMode","customBonus","entries","bonusStats","enemyDefRed_","enemyDefIgn_","defIgn","conditional","keys","layeredAssignment","dataObjForWeapon","weapon","refinement","refineIndex","teamBuff","setReadNodeKeys","deepClone","uiDataForTeam","teamData","activeCharKey","mergedData","mergeData","targetRef","buffs","calcs","customReadNodes","getReadNode","base","custom","newNode","customRead","accu","values","sourceKey","sourceBuff","buff","calc","asConst","resetData","readNode","targetKey","pivot","assign","origin","UIData","target","length","internal","type","errMsg","operands","Set","flatMap","filter","computeUIData","forEachNodes","formulas","topDown","bottomUp","visiting","visited","traverse","formula","has","add","delete","mapFormulas","topDownMap","bottomUpMap","topDownMapped","Map","bottomUpMapped","check","get","NaN","arrayEqual","a","b","every","i","allCommutativeMonoidOperations","reduce","mul","allOperations","res","sum_frac","threshold","pass","fail","commutativeMonoidOperationSet","optimize","topLevelData","shouldFold","_formula","deduplicate","flatten","constantFold","f","flattened","dep","elementCounts","array","wrap","common","counts","next","factored","count","Array","fill","candidatesByOperation","remainingCounts","currentCounts","commonCounts","nextCounts","total","dependency","currentCount","commonCount","candidates","candidate","candidateCounts","candidateCount","clear","processed","nextContextMap","fold","context","old","numericOperands","formulaOperands","folded","numericValue","isFinite","index","selected","table","Error","first","find","op","smallest","v1","v2","match","unmatch","list","reset","nextContext","assertUnreachable","shouldWrap","parent","children","nodes","display","this","getAll","calculated","uiInput","node","trace","isEmpty","unit","dependencies","assignment","empty","KeyMap","computeNodeDisplay","computeNode","_compute","_threshold","_constant","_subscript","_read","_data","_match","_lookup","_prio","_small","override","mergeInfo","mayNeedWrapping","variant","fixed","valueDisplay","color","valueString","prefixDisplay","sourceDisplay","name","createDisplay","illformedStr","readFirst","illformed","prereadAll","_accumulate","v1Node","v2Node","matchNode","unmatchNode","matching","emptyOn","makeEmpty","valueNode","thresholdNode","child","operand","score","variants","subVariant","sorted","sort","pop","accumulateInfo","identity","some","fStr","separator","strings","predisplay","string","item","itemFormula","createFormulaComponent","mergeFormulaComponents","style","fontSize","components","emptyValue"],"sourceRoot":""}