{"version":3,"file":"static/js/680.5e76b68d.chunk.js","mappings":"4/BAkDA,EAzBe,CACbA,YAAa,CAAEC,IAAAA,EAAKC,SAAAA,EAAUC,SAAAA,EAAUC,QAAAA,EAASC,MAAAA,GACjDC,KAAM,CACJC,O,6DACAC,M,4DACAC,M,4DACAC,O,6DACAC,Q,+DAEFC,MAAO,CACLC,QAAAA,EACAC,UAAAA,GAEFC,UAAW,CACTC,OAAAA,EACAC,IAAAA,EACAC,WAAAA,GAEFC,KAAM,CACJC,MAAAA,EACAC,MAAAA,EACAC,MAAAA,EACAC,MAAAA,K,+CC7CEC,GAAWC,EAAAA,EAAAA,IAAOC,EAAAA,EAAPD,EAAa,kBAAgB,CAC5CE,gBAD4B,EAAGC,MACRC,QAAQC,YAAYC,SAG7C,O,gDCJMC,GAAYP,EAAAA,EAAAA,IAAOC,EAAAA,EAAPD,EAAa,kBAAgB,CAC7CE,gBAD6B,EAAGC,MACTC,QAAQI,aAAaF,SAG9C,O,oJCAe,SAASG,EAAT,GAAqE,IAAD,IAA7CC,MAAAA,OAA6C,SAA3BC,GAA2B,YACzEC,GAAMC,EAAAA,EAAAA,GAAe,MAArBD,EACR,OAAIF,GACK,SAAC,KAAD,gBAAQI,MAAM,QAAQC,WAAW,SAAC,IAAD,KAAeJ,GAAhD,aAAyDC,EAAzD,+BACF,SAAC,KAAD,gBAAQE,MAAM,QAAQE,GAAI,CAAEC,EAAG,EAAGC,SAAU,IAASP,GAArD,cACL,SAAC,IAAD,S,sBCFW,SAASQ,EAAT,GAAmF,IAArDC,EAAoD,EAApDA,UAAWC,EAAyC,EAAzCA,QAASC,EAAgC,EAAhCA,aAAcC,EAAkB,EAAlBA,SAC7E,OAAQH,EAAYC,EAAQE,GAAaD,EAAeA,EAAaC,GAAYA,E,wNCDpE,SAASC,EAAT,GAAiG,IAAvEC,EAAsE,EAAtEA,MAAOF,EAA+D,EAA/DA,SAA+D,IAArDG,GAAAA,OAAqD,MAAhD,cAAgD,EAA9Bf,GAA8B,YAC7G,GAAgCgB,EAAAA,EAAAA,UAA6B,MAA7D,eAAOC,EAAP,KAAiBC,EAAjB,KACMC,EAAOC,QAAQH,GACfI,GAAcC,EAAAA,EAAAA,cAClB,SAACC,GAAD,OAAgDL,EAAYK,EAAMC,iBAClE,CAACN,IAEGO,GAAcH,EAAAA,EAAAA,cAClB,kBAAMJ,EAAY,QAClB,CAACA,IAGH,OAAO,UAAC,EAAAQ,SAAD,CAAUC,UAAU,SAAC,KAAD,gBAAQC,SAAS,SAAC,IAAD,KAA0B5B,GAA3C,cAAkD,SAAC,IAAD,CAAU6B,MAAO,QAAvF,WACL,SAAC,KAAD,kBACM7B,GADN,IAEEe,GAAIA,EACJ,gBAAc,aACd,gBAAc,OACd,gBAAeI,EAAO,YAASW,EAC/BC,QAASV,EACTO,SAAS,SAAC,IAAD,IAPX,SASGd,MAEH,SAAC,IAAD,CACEC,GAAG,aACHE,SAAUA,EACVE,KAAMA,EACNa,QAASP,EACTQ,cAAe,CACb,kBAAmBlB,GAErBgB,QAASN,EARX,UAWE,SAAC,EAAAC,SAAD,CAAUC,UAAU,SAAC,IAAD,CAAUE,MAAM,OAAOK,OAAO,SAAlD,SACGtB,W,0BCzCHuB,GAAU9C,E,SAAAA,IAAO,MAAO,CAC5B+C,KAAM,UACNlE,KAAM,QAFQmB,EAGC,oBAAGgD,KAAH,MAAmB,CAClCC,QAAS,eACTT,MAAO,OACPK,OAAO,GAAD,OAAY,UAHH,MAAU,EAAV,GAGT,MACNK,cAAe,kBAGjB,O,sMCVMC,GAAcnD,EAAAA,EAAAA,IAAOoD,EAAAA,EAAPpD,EAAc,gBAAGG,EAAH,EAAGA,MAAH,MAAgB,CAChDkD,SAAU,SACVC,WAAYnD,EAAMoD,QAAQ,GAC1BC,cAAerD,EAAMoD,QAAQ,OAGzBE,GAAiBzD,EAAAA,EAAAA,IAAO0D,EAAAA,EAAP1D,EAAkB,cAAGG,MAAH,MAAgB,CACvDwD,QAAS,EACTC,UAAW,OACXX,QAAS,OAAQY,cAAe,SAAUC,eAAgB,SAC1DC,cAAe,OACf,QAAS,CACPA,cAAe,YAOJ,SAASC,EAAT,GAAkF,IAA1DzC,EAAyD,EAAzDA,SAAU0C,EAA+C,EAA/CA,eAAmBtD,GAA4B,YAC9F,OAAO,SAACwC,GAAD,kBAAiBxC,GAAjB,cACL,SAAC8C,GAAD,kBAAoBQ,GAApB,cACE,SAAC,EAAA5B,SAAD,CAAUC,UAAU,SAAC,IAAD,WAAW,SAAC,IAAD,WAAa,SAAC,IAAD,CAAU4B,QAAQ,cAAc1B,MAAM,OAAOK,OAAQ,UAAjG,SACGtB,Y,gDCnBH4C,GAAyBnE,EAAAA,EAAAA,IAAOoE,EAAAA,EAAmB,CACvDC,kBAAmB,SAACC,GAAD,MAAmB,cAATA,GAAiC,kBAATA,IADxBtE,EAEQ,gBAAGG,EAAH,EAAGA,MAAH,IAAUoE,UAAAA,OAAV,MAAsB,YAAtB,MAAmCC,cAAAA,OAAnC,MAAmD,UAAnD,QAAoE,CACzG,kCAAmC,CACjC,IAAK,CACHtE,gBAAiBC,EAAMC,QAAQmE,GAAWjE,KAC1CQ,MAAOX,EAAMC,QAAQmE,GAAWE,cAElC,UAAW,CACTvE,gBAAiBC,EAAMC,QAAQmE,GAAWG,KAC1CC,WAAY,+BAEd,iBAAkB,CAChBzE,gBAAiBC,EAAMC,QAAQoE,GAAelE,KAC9CQ,MAAOX,EAAMC,QAAQoE,GAAeC,cAEtC,uBAAwB,CACtBvE,gBAAiBC,EAAMC,QAAQoE,GAAeE,MAEhD,iBAAkB,CAChBxE,gBAAiBC,EAAMC,QAAQmE,GAAWG,MAE5C,8BAA+B,CAC7BxE,gBAAiBC,EAAMC,QAAQoE,GAAeE,WAKpD,O,wPCrBe,SAASE,EAAT,GAA2G,IAAnFC,EAAkF,EAAlFA,SAAUC,EAAwE,EAAxEA,MAAOC,EAAiE,EAAjEA,SAAUC,EAAuD,EAAvDA,UAAWC,EAA4C,EAA5CA,YAAgBtE,GAA4B,YAC/GC,GAAMC,EAAAA,EAAAA,GAAe,MAArBD,EACR,OAAO,UAAC,IAAD,CAAKqC,QAAQ,OAAOiC,WAAW,SAASC,IAAK,EAA7C,WACL,SAAC,IAAD,CAAOvE,EAAGA,EAAGwE,QAASxE,EAAE,UAAxB,wBACA,UAAC,KAAD,kBAAiBD,GAAjB,eACE,SAAC,IAAD,CAAgBc,OAAO,SAAC,IAAD,CAAOb,EAAGA,EAAGwE,QAASxE,EAAE,WAAD,OAAYkE,IAAnC,SAAqD,CAAEA,MAAOlE,EAAE,WAAD,OAAYkE,OAAlG,SACGD,EAASQ,KAAI,SAAAC,GAAG,OACf,SAAC,IAAD,CAAoBC,SAAUT,IAAUQ,EAAKE,SAAUV,IAAUQ,EAAK5C,QAAS,kBAAMqC,EAASO,IAA9F,SAAqG1E,EAAE,WAAD,OAAY0E,KAAnGA,SAEnB,SAAC,IAAD,CAAQ5C,QAAS,kBAAMuC,GAAaD,IAAYjE,WAAW,SAAC,IAAD,CAAiB0E,KAAMT,EAAYU,EAAAA,IAAsBC,EAAAA,IAAgBC,UAAU,UAA9I,SACGZ,GAAY,SAAC,IAAD,CAAOpE,EAAGA,EAAGwE,QAAQ,YAArB,wBAAsD,SAAC,IAAD,CAAOxE,EAAGA,EAAGwE,QAAQ,aAArB,mC,iHCpBrES,EAAW,kBAAM,SAAC,IAAD,CAAiBJ,KAAMK,EAAAA,OACxCC,EAAQ,SAAC,GAAD,IAAGC,EAAH,EAAGA,MAAH,IAAUC,QAAAA,OAAV,gBACZ,SAAC,IAAD,CAAYnF,MAAOmF,EAAU,oBAAiBxD,EAAWyD,UAAU,OAAnE,SACGF,GAAQ,OAAIG,MAAMH,GAAOI,QAAQf,KAAI,SAACgB,EAAGC,GAAJ,OAAU,SAACT,EAAD,GAAeS,MAAS,S,2HCH/DC,EAAoB,CAC/BC,OAAO,SAAC,IAAD,CAAiBf,KAAMgB,EAAAA,KAC9BC,KAAK,SAAC,IAAD,CAAiBjB,KAAMkB,EAAAA,KAC5BC,SAAS,SAAC,IAAD,CAAiBnB,KAAMoB,EAAAA,KAChCC,OAAO,SAAC,IAAD,CAAiBrB,KAAMsB,EAAAA,KAC9BC,MAAM,SAAC,IAAD,CAAiBvB,KAAMwB,EAAAA,KAC7BC,MAAM,SAAC,IAAD,CAAiBzB,KAAM0B,EAAAA,KAC7BC,QAAQ,SAAC,IAAD,CAAiB3B,KAAM4B,EAAAA,KAC/BC,UAAU,SAAC,IAAD,CAAiB7B,KAAM8B,EAAAA,MAE7BC,GAAiBC,EAAAA,EAAAA,GAAaC,OAAOtB,KAAKG,IAAoB,SAAAjB,GAAG,OAAI,SAAC,IAAD,CAAWxE,MAAOwE,EAAKtE,GAAI,CAAE2G,WAAY,GAAzC,SAAgDpB,EAAkBjB,QAEvIsC,GAAQ,gBACZC,KAAK,SAAC,IAAD,CAAiBpC,KAAMqC,EAAAA,KAC5BC,IAAI,SAAC,IAAD,CAAiBtC,KAAMqC,EAAAA,KAE3BE,MAAM,SAAC,IAAD,CAAiBvC,KAAMwC,EAAAA,KAC7BC,KAAK,SAAC,IAAD,CAAiBzC,KAAMwC,EAAAA,KAE5BE,MAAM,SAAC,IAAD,CAAiB1C,KAAM2C,EAAAA,KAC7BC,KAAK,SAAC,IAAD,CAAiB5C,KAAM2C,EAAAA,KAE5BE,QAAQ,SAAC,IAAD,CAAiB7C,KAAM8C,EAAAA,KAC/BC,WAAW,SAAC,IAAD,CAAiB/C,KAAMgD,EAAAA,KAClCC,UAAU,SAAC,IAAD,CAAiBjD,KAAMkD,EAAAA,KACjCC,WAAW,SAAC,IAAD,CAAiBnD,KAAMoD,EAAAA,KAClCC,UAAU,SAAC,IAAD,CAAiBrD,KAAMsD,EAAAA,KACjCC,OAAO,SAAC,IAAD,CAAiBvD,KAAMwD,EAAAA,KAE9BC,QAAQ,SAAC,IAAD,CAAiBzD,KAAM0D,EAAAA,KAE/BC,SAAS,SAAC,IAAD,CAAiB3D,KAAM4D,EAAAA,KAChCC,SAAS,SAAC,IAAD,CAAiB7D,KAAM8D,EAAAA,MAE7B/B,GACAE,OAAO8B,YAAY9B,OAAOtB,KAAKoB,GAAgBiC,SAAQ,SAAAC,GAAG,MAAI,CAC/D,CAAC,GAAD,OAAIA,EAAJ,SAAgBlC,EAAekC,IAC/B,CAAC,GAAD,OAAIA,EAAJ,SAAgBlC,EAAekC,IAC/B,CAAC,GAAD,OAAIA,EAAJ,aAAoBlC,EAAekC,IACnC,CAAC,GAAD,OAAIA,EAAJ,WAAkBlC,EAAekC,IACjC,CAAC,GAAD,OAAIA,EAAJ,cAAqBlC,EAAekC,UAIxC,O,sOCrCMC,EAAkB,+BAAYC,MAAK,SAAAC,GAAG,OAAIA,EAAIC,WAoC/BC,EAAAA,WAGnB,WAAYC,EAA4BC,GAAiD,IAAD,4BAFxFC,WAEwF,OADhFD,UACgF,OAmBxFE,QAAU,WACR,IAAMC,EAAgB,EAAKF,MAAME,cACjC,MAAyB,UAAlBA,GAA+C,YAAlBA,GAAiD,aAAlBA,GArBmB,KA0BxFC,QAAU,WAAsC,IAArCX,EAAoC,uDAAlB,QAC3B,MAAI,YAAa,EAAKO,KACb,EAAKA,KACP,EAAKA,KAAKP,IA7BqE,KA+BxFY,UAAY,WAA4D,IAA3DC,EAA0D,uDAArC,QAChC,MAAI,WAAY,EAAKL,MAAc,EAAKA,MAAMM,OAClC,EAAKN,MAAMO,QAAQF,IAjCuD,KAmCxFG,eAAiB,SAACC,GAAD,MAAmCJ,EAAnC,uDAAwD,QAAxD,iBAAoE,EAAKD,UAAUC,UAAnF,aAAoE,EAAwBK,OAAOD,IAlClHE,KAAKX,MAAQF,EACba,KAAKZ,KAAOA,EAGgC,OAF7C,0BAGD,WAAa,OAAOY,KAAKX,MAAMnH,OAAM,gBACrC,WAAa,OAAO,SAAC,IAAD,CAAS+H,IAAKD,KAAKE,aAAc/J,GAAI,CAAE6B,OAAQ,MAAOmI,UAAW,OAAQC,WAAY,cAAgB,wBACzH,WAAqB,OAAO,4BAAOJ,KAAKpF,KAAZ,IAAmBoF,KAAK9H,UAAc,mBAClE,WAAgB,OAAO8H,KAAKX,MAAMgB,UAAS,oBAC3C,WAAiB,OAAOL,KAAKX,MAAMiB,WAAU,wBAC7C,WAAqB,OAAON,KAAKX,MAAMa,eAAc,qBACrD,WAAkB,OAAOF,KAAKX,MAAMkB,YAAW,kBAC/C,WAAe,OAAOP,KAAKX,MAAMmB,SAAQ,sBACzC,WAAmB,MAAO,eAAgBR,KAAKX,MAAQW,KAAKX,MAAMoB,gBAAa7I,IAAW,uBAC1F,WAAoB,MAAO,YAAaoI,KAAKX,MAAQxC,OAAOtB,KAAKyE,KAAKX,MAAMO,SAAW,KAAI,yBAC3F,WAAsB,OAAOI,KAAKX,MAAME,gBAAe,6BACvD,WAA0B,OAAOS,KAAKX,MAAMqB,oBAAmB,sBAM/D,WACE,MAAO,YAAaV,KAAKX,SAC1B,mBApBD,WAAsB,OAAOP,MAAiB,EAR3BI,GAAAA,EAOZyB,IAAM,SAACC,GAAD,OAAqEA,EAAU9B,EAAgBC,MAAK,SAAA8B,GAAC,OAAIA,EAAED,WAAYhJ,GAPjHsH,EAwCZ4B,eAAiB,SAACC,EAAeC,GAAhB,gBACnBD,EADmB,YACVE,EAAAA,GAAkBD,KAGlC,IASME,EAAe,SAACpB,EAAkCqB,EAA6BC,GACnF,MAAO,CACLxK,MAAOuK,EAAG,GAAD,OAAIrB,EAAJ,UACTlF,MAAM,SAAC,IAAD,CAASzC,KAAM,EAAGhC,GAAI,CAAEkL,GAAI,GAAKpB,IAAKmB,IAC5CE,QAAQ,SAAC,IAAD,CAASrL,MAAM,UAAf,UAA0BsL,EAAAA,EAAAA,IAAG,WAAD,OAAYzB,MAChD0B,YAAaL,EAAG,GAAD,OAAIrB,EAAJ,mBAqBb2B,EAAuE,CAC3E,UAAYC,EAAAA,EAAAA,IAAUC,EAAAA,GAAAA,IAAW,EAAG,GACpC,UAAYD,EAAAA,EAAAA,IAAUC,EAAAA,GAAAA,IAAW,EAAG,GACpC,gBAAkBD,EAAAA,EAAAA,IAAUC,EAAAA,GAAAA,cAAqB,EAAG,GACpD,gBAAkBD,EAAAA,EAAAA,IAAUC,EAAAA,GAAAA,cAAqB,EAAG,GACpD,gBAAkBD,EAAAA,EAAAA,IAAUC,EAAAA,GAAAA,cAAqB,EAAG,GACpD,gBAAkBD,EAAAA,EAAAA,IAAUC,EAAAA,GAAAA,cAAqB,EAAG,GACpD,gBAAkBD,EAAAA,EAAAA,IAAUC,EAAAA,GAAAA,cAAqB,EAAG,GACpD,gBAAkBD,EAAAA,EAAAA,IAAUC,EAAAA,GAAAA,cAAqB,EAAG,IAEtD,SAASC,EAAgB9B,EAAkC+B,GACzD,OAAKJ,EAAoB3B,IAKrB,CAAC,WAAY,YAAYgC,SAAShC,IACpCiC,EAAaJ,EAAAA,GAAAA,IACbK,EAA+B,KAAxBlC,EAAUmC,OAAO,GAAW,EAAI,IAEvCF,EAAaJ,EAAAA,GAAAA,cACbK,GAAOlC,EAAUmC,OAAO,IAGnBJ,GACHH,EAAAA,EAAAA,IAAUK,EAAYC,EAAKH,GAAoB,GAC/CJ,EAAoB3B,IAdf+B,EAET,IAAIE,EACAC,EAoBC,IAAME,EAAgB,SAACC,EAAoBC,EAAqBC,EAAwDC,GAC7H,MAAsB,aAATH,EACT,CAAC,SAAC1H,GAAD,OAAiB,SAAC,IAAD,CAAW8H,GAAG,oBAAoBC,MAAK,UAAKF,EAAL,YAAoB7H,QAC7EgI,EAAAA,EAAAA,IAAM,OAAQN,GAFXhB,GAAP,eAIA,OADAkB,EAAOK,KAAOC,EAAAA,EAAAA,YAAmBP,GAC1B,CACLQ,eAAgB,SAAC9C,EAAkC+C,GAAnC,aA5EG,SAAC/C,EAAkCqB,EAA6BC,EAAayB,GAA7E,MAAsI,CAC3J3K,KAAMiJ,EAAG,GAAD,OAAIrB,EAAJ,UACRsB,IAAAA,EACA0B,SAAS,GAAD,eACY,SAAdhD,EAAuB,CAAC,CAAEiD,KAAM5B,EAAG,GAAD,OAAIrB,EAAJ,mBAAkC,KADlE,OAEF+C,GAAe,MAuEoED,CAAe9C,EAAWqB,EAAZ,UAAgBkB,EAAOvC,UAAvB,QAAqC,GAAI+C,IAC9IG,eAAgB,SAAClD,EAAkCmD,GAAnC,aA3DG,SAACnD,EAAkCqB,EAA6BC,EAAa6B,GAA7E,eAAC,UACnBA,GADkB,IAErBC,OAAQhC,EAAapB,EAAWqB,EAAIC,GACpCS,QAASD,EAAgB9B,EAAWmD,EAAepB,WAwDsCmB,CAAelD,EAAWqB,EAAZ,UAAgBkB,EAAOvC,UAAvB,QAAqC,GAAImD,IAC9IE,eAAgB,SAACrD,EAAkCsD,GAAnC,OAtDG,SAACtD,EAAkCsD,GAAnC,eAAC,UACnBA,GADkB,IAErBvB,QAASD,EAAgB9B,EAAWsD,EAAcvB,WAoDsCsB,CAAerD,EAAWsD,IAChHC,oBAAqB,SAACvD,EAAkCwD,GAAnC,aAlDG,SAACxD,EAAkCwD,EAAsCnC,EAA6BC,GAAtG,eAAC,UACxBkC,GADuB,IAE1BJ,QAAO,kBAAMhC,EAAapB,EAAWqB,EAAIC,IAASkC,EAAYJ,QAC9DrB,QAASD,EAAgB9B,EAAWwD,EAAYzB,WA+CmDwB,CAAoBvD,EAAWwD,EAAanC,EAAzB,UAA6BkB,EAAOvC,UAApC,QAAkD,Q,uMCtK7JyB,EAAK,SAACgC,EAAgBC,GAAjB,OAAqC,SAAC,IAAD,CAAWjB,GAAG,QAAQC,MAAOe,EAAQC,OAAQA,KACvFC,EAAM,SAACF,GAAD,OAAoB,SAAC,IAAD,CAAWhB,GAAG,YAAYC,MAAOe,KAE3DG,EAAe,SAACC,GAAD,OAAoBC,EAAAA,EAAAA,IAAiB,CAAC,eAAF,eAAoBD,MAC7E,SAASE,EAAKpJ,EAAgDqJ,GACnE,IAAMH,EAAO,CAAClJ,EAAKqJ,GAEnB,MAAO,CAACH,EADKD,EAAaC,IAQrB,SAASlB,EAAMsB,EAAyCtJ,GAC7D,MAAO,CACL,SAAC8I,GAAD,OAAoB,SAAC,IAAD,CAAWhB,GAAE,UAAKwB,EAAL,YAAgBtJ,EAAhB,QAA2B+H,MAAOe,KACnE,SAACA,EAAgBC,GAAjB,OAAqC,SAAC,IAAD,CAAWjB,GAAE,UAAKwB,EAAL,YAAgBtJ,GAAO+H,MAAOe,EAAQC,OAAQA,Q,uTCTpG,SAASQ,EAAa5E,EAAY6E,GAchC,OAbAC,EAAAA,EAAAA,IAAY9E,EAAM,IAAI,SAAC+E,GAAD,OAAYA,EAAEC,aAAW,SAACD,EAAYR,GAC1C,aAAZA,EAAK,KACPA,EAAOA,EAAK1B,MAAM,GACbkC,EAAEE,OAAMF,EAAEE,KAAO,IACtBF,EAAEE,KAAKC,YAAa,GAEtB,IAAMC,GAAYC,EAAAA,EAAAA,IAAa7C,EAAAA,GAAOgC,GAClCY,EACFJ,EAAEE,MAAF,0BAAcF,EAAEE,MAASE,EAAUF,MAAnC,IAAyCI,YAAQ7M,EAAWqM,OAAAA,IACzC,UAAZN,EAAK,IACZe,QAAQC,MAAR,iBAAwBV,EAAxB,4CAAkEN,OAG/DvE,EAET,SAASwF,EAAmBC,GAAkE,IAA5CC,EAA2C,uDAAT,EAC5EC,EAAcC,EAAAA,EAAAA,cAAuBH,EAAII,YAAaJ,EAAIrE,OAAQ0E,KAAKC,IAAID,KAAKE,IAAIN,EAAsC,EAAbD,EAAIrE,QAAaqE,EAAI9D,QAClIsE,EAA+D,GAGrE,OAFAA,EAAMC,KAAK,CAACT,EAAII,YAAaF,IAC7BF,EAAIU,SAASC,SAAQ,gBAAG/K,EAAH,EAAGA,IAAKgL,EAAR,EAAQA,cAAR,OAA4BhL,GAAO4K,EAAMC,KAAK,CAAC7K,EAAKgL,OAClE,CACLZ,KAAI,kBACChI,OAAO8B,YAAY0G,EAAM7K,KAAI,+BAAEC,EAAF,KAAOR,EAAP,YAC9BQ,EAAIiL,SAAS,KAAO,CAACjL,GAAKkL,EAAAA,EAAAA,IAAQ1L,EAAQ,MAAQ,CAACQ,GAAKmL,EAAAA,EAAAA,IAAS3L,SAFlE,cAGA4K,EAAIgB,QAAU,CACbhP,IAAI+O,EAAAA,EAAAA,IAASf,EAAIhO,IAAKiP,KAAKF,EAAAA,EAAAA,IAASf,EAAIkB,WAG5CC,QAAO,UACJnB,EAAIkB,QAASH,EAAAA,EAAAA,IAAS,KAI7B,SAASK,EAAoBC,GAyB3B,IAzB0D,IAAD,EACnDC,EAAe,CACnBC,KAAKR,EAAAA,EAAAA,IAASM,EAAKnF,OACnBsF,eAAeT,EAAAA,EAAAA,IAASM,EAAKG,eAC7BC,KAAKV,EAAAA,EAAAA,IAASM,EAAKlF,WACnBuF,SAAU,CACR1R,KAAMqR,EAAKM,cAAeZ,EAAAA,EAAAA,IAASM,EAAKM,mBAAgB5O,GAE1D6O,OAAQ,CACN/D,MAAMkD,EAAAA,EAAAA,IAASM,EAAKvG,OAAO+C,MAC3BgE,OAAOd,EAAAA,EAAAA,IAASM,EAAKvG,OAAO+G,OAC5BC,OAAOf,EAAAA,EAAAA,IAASM,EAAKvG,OAAOgH,QAE9BC,OAAM,mBACDhK,EAAAA,EAAAA,GAAaiK,EAAAA,GAAAA,KAAuB,SAAAhI,GAAG,gBAAOA,EAAP,aAAoB,SAAAA,GAAG,aAC/D8G,EAAAA,EAAAA,KAAQ,UAACO,EAAKY,cAAL,UAAsBjI,EAAIoD,MAAM,GAAI,GAApC,sBAAD,QAAwD,IAAM,SAFrE,IAGHlB,OAAO6E,EAAAA,EAAAA,IAAQ,UAACM,EAAKY,cAAcC,kBAApB,QAAkCb,EAAKnF,SAExDiG,IAAK,CACHC,SAASrB,EAAAA,EAAAA,IAASM,EAAKe,SACvBC,UAAUtB,EAAAA,EAAAA,IAASM,EAAKiB,eAE1BC,YAAa,IAGf,MAA2BvK,OAAOwK,QAAQnB,EAAKoB,YAA/C,gBAAK,sBAAO7M,EAAP,KAAYR,EAAZ,KACHkM,EAAOiB,YAAa3M,GAAOA,EAAIiL,SAAS,MAAOC,EAAAA,EAAAA,IAAQ1L,EAAQ,MAAO2L,EAAAA,EAAAA,IAAS3L,GASjF,OAPIiM,EAAKY,cAAcS,eACrBpB,EAAOM,OAAQc,cAAe5B,EAAAA,EAAAA,IAAQO,EAAKY,cAAcS,aAAe,MACtErB,EAAKY,cAAcU,eACrBrB,EAAOS,MAAOa,QAAS9B,EAAAA,EAAAA,IAAQO,EAAKY,cAAcU,aAAe,OAEnEtD,EAAAA,EAAAA,IAAYgC,EAAKwB,YAAa,CAAC,gBAAgB,SAACvD,GAAD,MAAyB,kBAANA,KAAgB,SAACA,EAAW5I,GAAZ,OAChFoM,EAAAA,EAAAA,IAAkBxB,EAAQ5K,GAAMqK,EAAAA,EAAAA,IAASzB,OACpCgC,EAET,SAASyB,EAAiBC,GACxB,MAAO,CACLA,OAAQ,CACNhR,IAAI+O,EAAAA,EAAAA,IAASiC,EAAOhR,IACpBuP,KAAKR,EAAAA,EAAAA,IAASiC,EAAO9G,OACrBuF,KAAKV,EAAAA,EAAAA,IAASiC,EAAO7G,WACrB8G,YAAYlC,EAAAA,EAAAA,IAASiC,EAAOC,YAC5BC,aAAanC,EAAAA,EAAAA,IAASiC,EAAOC,WAAa,KAKhD,IAAME,GAAWC,EAAAA,EAAAA,KAAgBC,EAAAA,EAAAA,IAAUvG,EAAAA,IAAQ,CAAC,aACpD,SAASwG,EAAcC,EAAsCC,GAI3D,IAAMC,EAAazL,OAAOwK,QAAQe,GAAU5N,KAAI,+BAAEC,EAAF,KAAO2E,EAAP,WAAiB,CAAC3E,GAAD,UAAW8N,EAAUnJ,QAChF+G,EAAStJ,OAAO8B,YAAY2J,EAAW9N,KAAI,kBAC/C,EAD+C,eACzC,CAAEgO,UAAW,GAAYC,MAAO,GAAcC,MAAO,SAEvDC,EAAkB,GACxB,SAASC,EAAYjF,GACnB,IAAMkF,EAAoB,aAAZlF,EAAK,IACfa,EAAAA,EAAAA,IAAawD,EAAUrE,EAAK1B,MAAM,KAClCuC,EAAAA,EAAAA,IAAa7C,EAAAA,GAAOgC,GACxB,GAAIkF,EAAM,OAAOA,EACjB,IAAMC,GAAStE,EAAAA,EAAAA,IAAamE,EAAiBhF,GAC7C,GAAImF,EAAQ,OAAOA,EACnB,IAAMC,GAAUC,EAAAA,EAAAA,IAAWrF,GAG3B,MAFgB,aAAZA,EAAK,IAAiC,UAAZA,EAAK,KAAgBoF,EAAQE,KAAO,QAClEtB,EAAAA,EAAAA,IAAkBgB,EAAiBhF,EAAMoF,GAClCA,EAGTlM,OAAO2G,OAAO2C,GAAQX,SAAQ,gBAAGgD,EAAH,EAAGA,UAAWC,EAAd,EAAcA,MAAOC,EAArB,EAAqBA,MAArB,OAC5BJ,EAAW9C,SAAQ,YAA0B,IAAD,eAAvB0D,EAAuB,KACpCC,EADoC,KAChBnB,SAEpBoB,EAAa,GAAIC,GAAanB,EAAAA,EAAAA,IAAU,CAAEF,SAAUmB,IAC1DV,EAAMnD,KAAK8D,GACXV,EAAMQ,GAAaG,GAUnBnF,EAAAA,EAAAA,IAAYiF,EAAY,IAAI,SAAChF,GAAD,OAAYA,EAAEC,aAAW,SAACD,EAAsBR,GAC1E,IAAMU,GAAU,mBAAQG,EAAAA,EAAAA,IAAa7C,EAAAA,GAAOgC,IAA5B,IAAmCM,OAAQiF,EAAWzE,YAAQ7M,EAAW0R,QA7HjF,QA8HR3B,EAAAA,EAAAA,IAAkByB,EAAMzF,GAAM4F,EAAAA,EAAAA,IAAUX,EAAY,CAAC,YAAF,eAAiBjF,KAAQ0F,EAAMhF,KAElFH,EAAAA,EAAAA,IAAYC,EAAG,IAAI,SAACA,GAAD,MAA6B,UAAhB,OAADA,QAAC,IAADA,OAAA,EAAAA,EAAGC,cAAsB,SAACD,GAGvD,IAAIqF,EAAiDpK,EAFnC,eAAd+E,EAAER,KAAK,KAGO,WAAdQ,EAAER,KAAK,IACT6F,EAAWZ,EAAYzE,EAAER,KAAK1B,MAAM,IACpC7C,EAAOoJ,IAEPgB,EAAWrF,EACX/E,EAAO+G,EAAO+C,GAAWV,YAE3Bb,EAAAA,EAAAA,IAAkB0B,EAAMlF,EAAER,MAAM4F,EAAAA,EAAAA,IAAUC,EAAUpK,iBAK5DkJ,EAAW9C,SAAQ,YAAwB,IAAD,eAArBiE,EAAqB,KAAVrK,EAAU,YACjCA,EAAK4I,SACZ,MAA6B7B,EAAOsD,GAA5BjB,EAAR,EAAQA,UACFY,EAAOb,EADb,EAAmBE,QAEnBvE,EAAAA,EAAAA,IAAW,OAACkF,QAAD,IAACA,EAAAA,EAAQ,GAAI,IAAK,SAAAjF,GAAC,OAAIA,EAAEC,aAAY,SAACD,EAAYR,GAAoB,IAAD,EAK9EQ,EAAEE,MAAF,6BAAeG,EAAAA,EAAAA,IAAawD,EAAUrE,UAAtC,aAAc,EAAgEU,MAA9E,IAAoFI,OAAQ,WAAYiF,MAzJvE,UA2JnC7M,OAAO8M,OAAOnB,EAAWD,EAAU,CAACnJ,EAAMgK,EAAM,CAAEpB,SAAUoB,EAAMf,eAAezC,EAAAA,EAAAA,IAASyC,OAC1FG,EAAS,OAAaA,KAExB,IAAMoB,EAAS,IAAIC,EAAAA,OAAOjS,OAAkBA,GAC5C,OAAOiF,OAAO8B,YAAY9B,OAAOwK,QAAQlB,GAAQ3L,KAAI,+BAAEC,EAAF,KAAOR,EAAP,WACnD,CAACQ,EAAK,CACJqP,OAAQ,IAAID,EAAAA,EAAO5P,EAAMuO,UAAWoB,GACpCnB,MAAO5L,OAAO8B,YAAY9B,OAAOwK,QAAQpN,EAAMyO,OAAOlO,KAAI,+BAAEC,EAAF,KAAOR,EAAP,WACxD,CAACQ,EAAK,IAAIoP,EAAAA,EAAO5P,EAAO2P,cAGhC,SAASrB,EAAUnJ,GAuBjB,OAAOA,EAAK2K,OAtBZ,SAASC,EAAS5K,EAAauE,GAC7B,GAAIvE,EAAK2K,QAAU,EAAG,OAAO3K,EAAK,GAClC,GAAIA,EAAK,GAAGgF,UAAW,CAAC,IAAD,EACL,aAAZT,EAAK,KAAmBA,EAAOA,EAAK1B,MAAM,IAC9C,iBAAsBuC,EAAAA,EAAAA,IAAa7C,EAAAA,GAAOgC,UAA1C,QAAuG,GAAjGsF,EAAN,EAAMA,KAAMgB,EAAZ,EAAYA,KACZ,GAAgB,UAAZtG,EAAK,GAAgBsF,EAAO,WAC3B,QAAarR,IAATqR,EAAoB,CAC3B,IAAMiB,EAAM,yDAAuDvG,GAIjEe,QAAQC,MAAMuF,GAEhBjB,EAAgB,WAATgB,EAAoB,MAAQ,QAGrC,MADkC,CAAE7F,UAAW6E,EAAMkB,SAAU/K,GAG/D,OAAOvC,OAAO8B,aAAY,OAAI,IAAIyL,IAAIhL,EAAKR,SAAQ,SAAAuF,GAAC,OAAItH,OAAOtB,KAAK4I,QACjE3J,KAAI,SAAAC,GAAG,MAAI,CAACA,EAAKuP,EAAS5K,EAAK5E,KAAI,SAAA2J,GAAC,OAAIA,EAAE1J,MAAM4P,QAAO,SAAAlG,GAAC,OAAIA,KAAnC,kBAA2CR,GAA3C,CAAiDlJ,UAG5DuP,CAAS5K,EAAM,IAAM,GAG5C,SAASkL,EAAclL,GACrB,OAAO,IAAIyK,EAAAA,EAAOtB,EAAUnJ,QAAOxH,K,2JClKnB2S,E,4EApCab,GAAQ,EAEjCa,EAAc1D,EAAAA,GACd2D,EAAa,CAAC,OAAQ,QAAS,SAC/BC,EAAW,CAAC,SAAU,UAAW,WAAY,QAAS,QAAS,aAC/DC,EAAiB,CAAC,KAAM,MAAO,MAAO,OAAQ,MAAO,OAAQ,SAAU,YAAa,YAAa,WAAY,eAAgB,aAAc,YAAa,YAAa,gBAAiB,aAAc,WAAY,SAChNC,EAAoB,CAAC,aAAc,YAAa,iBAAkB,eAAgB,SAClFC,EAAgB,CAAC,WAAY,QAM7BC,EAAW,UACZH,GADY,OAEZ,CAAE,MAAO,WAAT,OAAuBC,EAAsBC,EAAkBH,GAAoBjQ,KAAI,SAAA2J,GAAC,gBAAOA,EAAP,cAEvF2G,EAAc,kBACfP,EAAY3L,SAAQ,SAAAuF,GAAC,MAAI,CAAC,GAAD,OACvBA,EADuB,qBAEvBA,EAFuB,uBAGvBA,EAHuB,eADV,OAKfsG,EAAS7L,SAAQ,SAAAuF,GAAC,MAAI,CAAC,GAAD,OACpBA,EADoB,qBAEpBA,EAFoB,uBAGpBA,EAHoB,mBALP,CASlB,eATkB,OAUf4G,EAAAA,IAVe,CAWlB,gBApBc,CACd,UAAW,cAAe,oBAAqB,qBAAsB,qBACrE,WAAY,UAAW,SAAU,WAAY,UAAW,eAAgB,UAAW,YAsB/EpL,GAAS/C,EAAAA,EAAAA,GAAa4N,GAAY,SAAAhP,GAAC,OAAIwP,EAAAA,EAAAA,SACvCC,GAAkBrO,EAAAA,EAAAA,GAAaiO,GAAa,SAAApQ,GAAG,OAAIuQ,EAAAA,EAAAA,SAAKpT,EAAW,CAAE6C,IAAAA,OACrEyQ,GAAqBtO,EAAAA,EAAAA,GAAakO,GAAgB,SAAArQ,GAAG,OAAIuQ,EAAAA,EAAAA,SAAKpT,EAAW,CAAE6C,IAAAA,OAAjF,UAEkB8P,GAAAA,IAAlB,2BAA+B,CAAC,IAArB1L,EAAoB,QAC7BqM,EAAmB,GAAD,OAAIrM,EAAJ,UAAgBwF,KAAMhL,QAAUwF,EAClDqM,EAAmB,GAAD,OAAIrM,EAAJ,eAAqBwF,KAAMhL,QAAUwF,EACvDqM,EAAmB,GAAD,OAAIrM,EAAJ,cAAoBwF,KAAMhL,QAAUwF,EACtDqM,EAAmB,GAAD,OAAIrM,EAAJ,YAAkBwF,KAAMhL,QAAUwF,EACpDoM,EAAgB,GAAD,OAAIpM,EAAJ,UAAgBwF,KAAMhL,QAAUwF,GAChD,8BACD,wBAA2B8L,EAAsBC,GAAjD,eAAiE,CAA5D,IAAM1D,EAAQ,KACjB+D,EAAgB,GAAD,OAAI/D,EAAJ,UAAqB7C,KAAMhL,QAAU6N,EAGtD,SAASiE,EAAmB9G,EAAYpK,GAGtC,OAFAA,GAAQiO,EAAAA,EAAAA,IAAUjO,IAClBiK,EAAAA,EAAAA,IAAYjK,EAAO,IAAI,SAACkK,GAAD,OAAYA,EAAEC,aAAW,SAACD,GAAD,OAA0BA,EAAEE,MAAF,kBAAcA,GAASF,EAAEE,SAC5FpK,EAST,IAPqBgP,EAAgChP,EAO/C0H,GAAQsG,EAAAA,EAAAA,KAAgBC,EAAAA,EAAAA,IAAU,CACtCG,eAAe+C,EAAAA,EAAAA,MACfxK,SAASwK,EAAAA,EAAAA,MAAcC,SAASD,EAAAA,EAAAA,MAAcE,YAAYF,EAAAA,EAAAA,MAC1DhF,KAAK4E,EAAAA,EAAAA,SAAKpT,EAAW,CAAE6C,IAAK,QAASgK,OAAQ,SAAW4B,eAAe2E,EAAAA,EAAAA,MAAQ1E,KAAK0E,EAAAA,EAAAA,MAAQO,SAASP,EAAAA,EAAAA,MAErGzE,SAAU,CACRiF,iBAAiBJ,EAAAA,EAAAA,IAAW,SAC5BK,oBAAoBL,EAAAA,EAAAA,IAAW,SAC/BvW,MAAMuW,EAAAA,EAAAA,IAAW,UAGnBvC,MAAMjM,EAAAA,EAAAA,GAAa,CAAC,MAAO,KAAM,QAAQ,SAAAnC,GAAG,OAAIuQ,EAAAA,EAAAA,IAAK,MAAO,CAAEvQ,IAAAA,OAC9D2M,YAAa+D,EAAgB,CAAE1G,OAAQ,SAAUiF,MAAAA,IAArB,QAAC,UACxBuB,GAAoBC,IAEzBQ,OAAM,UAAM/L,GACZ8G,QAAO,0BAAM9G,GAAWsL,GAAoBC,GAC5CS,MAAOR,EAAgB,CAAE1G,OAAQ,QAASiF,MAAAA,IAApB,QAAC,kCAClB/J,IAAWiM,EAAAA,EAAAA,IAAkBpB,GAAY,SAAA7K,GAAM,MAAI,CAAC,GAAD,OAAIA,EAAJ,UAAmBqL,EAAAA,EAAAA,WACtEC,GAAoBC,GAFH,IAIpBW,gBAAgBb,EAAAA,EAAAA,SAAKpT,EAAW,CAAE6C,IAAK,iBAGzCoK,IAAKsG,EAAgB,CAAE1G,OAAQ,MAAO6E,QAnFxB,OAmFM,QAAC,WAChB1M,EAAAA,EAAAA,GAAa8N,GAAgB,SAAAjQ,GAAG,OAAIwQ,EAAgBxQ,QACpDmC,EAAAA,EAAAA,GAAakP,EAAAA,IAAa,SAAAtQ,GAAC,MAAK,CAAE3E,IAAIuU,EAAAA,EAAAA,MAActF,KAAKsF,EAAAA,EAAAA,YAE9DpF,QAAQpJ,EAAAA,EAAAA,GAAamP,EAAAA,IAAiB,SAAAjG,GAAG,OAAIkF,EAAAA,EAAAA,IAAK,MAAO,CAAEvQ,IAAKqL,OAEhE+B,OAAQsD,EAAgB,CAAE1G,OAAQ,SAAU6E,QAzF9B,MAyFyC,CACrDzS,IAAIuU,EAAAA,EAAAA,MACJ3Q,KAAK2Q,EAAAA,EAAAA,MAAcnB,MAAMmB,EAAAA,EAAAA,MAEzBhF,KAAK4E,EAAAA,EAAAA,MAAQ1E,KAAK0E,EAAAA,EAAAA,MAAQlD,YAAYkD,EAAAA,EAAAA,MAAQjD,aAAaiD,EAAAA,EAAAA,MAC3DvV,MAAMuV,EAAAA,EAAAA,MAAQgB,KAAKhB,EAAAA,EAAAA,MAAQiB,MAAMjB,EAAAA,EAAAA,QAGnCpE,OAAM,wBACJpJ,KAAKwN,EAAAA,EAAAA,IAAK,MAAO,CAAEvQ,IAAK,iBAAkBiP,MAAAA,MACvC9M,EAAAA,EAAAA,GAAa2N,EAAY/P,KAAI,SAAAqE,GAAG,gBAAOA,EAAP,iBAAiC,SAAArD,GAAC,OAAIwP,EAAAA,EAAAA,UAFtE,IAIHjK,OAAOiK,EAAAA,EAAAA,SAAKpT,EAAW,CAAE6C,IAAK,iBAC3BmR,EAAAA,EAAAA,IAAkBrB,GAAa,SAAA1L,GAAG,MAAI,CAAC,GAAD,OAAIA,EAAJ,UAAgBmM,EAAAA,EAAAA,SAAKpT,QAL3D,IAMHsU,QAAQlB,EAAAA,EAAAA,SAAKpT,GACb6P,QAAQuD,EAAAA,EAAAA,IAAK,MAAO,CAAEvQ,IAAK,eAAgBiP,MAAAA,MAG7C1C,IAAK,CACHnI,KAAKuM,EAAAA,EAAAA,MAAclE,UAAUkE,EAAAA,EAAAA,MAAce,MAAMf,EAAAA,EAAAA,MAAcnE,SAASmE,EAAAA,EAAAA,MACxEvC,MAAMmC,EAAAA,EAAAA,IAAK,MAAO,CAAEvQ,IAAK,SAEzB2R,UAAUpB,EAAAA,EAAAA,IAAK,MAAO,CAAEvQ,IAAK,OAAQiP,MAAAA,IACrC2C,QAAQrB,EAAAA,EAAAA,IAAK,MAAO,CAAEvQ,IAAK,SAAUiP,MAAAA,IACrC4C,KAAKtB,EAAAA,EAAAA,UAIDnC,EAA6DlH,EAA7DkH,KAAM6C,EAAuD/J,EAAvD+J,MAAOtE,EAAgDzF,EAAhDyF,YAAaX,EAAmC9E,EAAnC8E,OAAQkF,EAA2BhK,EAA3BgK,MAAO9G,EAAoBlD,EAApBkD,IAAKmC,EAAerF,EAAfqF,IAAKJ,EAAUjF,EAAViF,MAjEtCqC,EAoEZ,MApE4ChP,EAoErC,CACdyR,MAAAA,EAAOtE,YAAAA,EAAaX,OAAAA,EAAQ5B,IAAAA,EAC5B8G,OAAO/O,EAAAA,EAAAA,GAAaiO,GAAa,SAAA0B,GAAI,OAAIZ,EAAMY,QArE/CrI,EAAAA,EAAAA,IAAYjK,EAAO,IAAI,SAACkK,GAAD,OAAYA,EAAEC,aAAW,SAACD,GAC3B,SAAhBA,EAAEC,WAAmC,WAAXD,EAAE8F,OAAmB9F,EAAE8E,KAAOA,MAsEhEyC,EAAMhJ,KAAK2B,KAAO,CAAE5J,IAAK,aACzBiR,EAAMhF,MAAMrC,KAAO,CAAE5J,IAAK,cAC1BiR,EAAM/E,MAAMtC,KAAO,CAAE5J,IAAK,cAC1BoO,EAAKxL,IAAIgH,KAAO,CAAE5J,IAAK,MAAOgK,OAAQ,OAAQiF,MAAAA,UACvCiC,EAAMhO,UAAU0G,KAAMqF,MAC7BiC,EAAMhO,UAAU0G,KAAMI,OAAS,WAK/B,IAAM+H,GAAeC,EAAAA,EAAAA,IAAIC,EAAAA,IAAKC,EAAAA,EAAAA,IAAK,GAAK,GAAGC,EAAAA,EAAAA,IAAKjB,EAAMlO,OAAQ,QAEjDoP,GAAoBC,EAAAA,EAAAA,IAAO9F,EAAInI,IAAK,CAC/C1C,MAAM2Q,EAAAA,EAAAA,IAAO9F,EAAIE,SAAU,CAAE6F,eAAenH,EAAAA,EAAAA,IAAS,YAAaoH,WAAWpH,EAAAA,EAAAA,IAAS,cAAWhO,GACjGqE,OAAOgR,EAAAA,EAAAA,IAASjG,EAAIE,SAAU,iBAAkB,YAChD7K,MAAM4Q,EAAAA,EAAAA,IAASjG,EAAIE,SAAU,YAAa,cACzCtP,GAEGsV,EAAe,CACnBzG,QAAO,2BACF7J,EAAAA,EAAAA,GAAa4N,GAAY,SAAA7K,GAAM,OAAI+L,EAAM/L,QACzC/C,EAAAA,EAAAA,GAAakO,GAAgB,SAAArQ,GAAG,OAAI2M,EAAY3M,QAChDmC,EAAAA,EAAAA,GAAaiO,GAAa,SAAApQ,GAC3B,IAAM0P,EAAsB,GAC5B,OAAQ1P,GACN,IAAK,MAAO,IAAK,MAAO,IAAK,KAC3B0P,EAAS7E,MAAKqH,EAAAA,EAAAA,IAAK9D,EAAKpO,IAAMgS,EAAAA,EAAAA,IAAIC,EAAAA,GAAKjG,EAAO,GAAD,OAAIhM,EAAJ,SAC7C,MACF,IAAK,YACH0P,EAAS7E,MAAKK,EAAAA,EAAAA,IAAQ,IAAM,CAAElL,IAAAA,EAAKgK,OAAQ,aACzCqI,EAAAA,EAAAA,IAAO9F,EAAImF,MAAMvP,EAAAA,EAAAA,GAAa6N,GAAU,SAAA0B,GAAI,OAAI1F,EAAO,GAAD,OAAI0F,EAAJ,kBAAwB,IAChF,MACF,IAAK,WACHhC,EAAS7E,MAAKK,EAAAA,EAAAA,IAAQ,GAAK,CAAElL,IAAAA,EAAKgK,OAAQ,aACxCqI,EAAAA,EAAAA,IAAO9F,EAAInI,KAAKjC,EAAAA,EAAAA,GAAa2N,GAAa,SAAA1L,GAAG,OAAI4H,EAAO,GAAD,OAAI5H,EAAJ,iBAAsB,IAC7EiO,EAAAA,EAAAA,IAAO9F,EAAImF,MAAMvP,EAAAA,EAAAA,GAAa6N,GAAU,SAAA5L,GAAG,OAAI4H,EAAO,GAAD,OAAI5H,EAAJ,iBAAsB,IAC7E,MACF,IAAK,YACHsL,EAAS7E,MAAKK,EAAAA,EAAAA,IAAQ,EAAG,CAAElL,IAAAA,EAAKgK,OAAQ,aAG5C,OAAOgI,EAAAA,GAAAA,WAAA,UAAO,UAAItC,EAAJ,CAActF,EAAIpK,GAAM2M,EAAY3M,KAAM4P,QAAO,SAAAlG,GAAC,OAAIA,WAGxEwH,OAAM,2CACD/O,EAAAA,EAAAA,GAAa4N,GAAY,SAAA7K,GAAM,OAAI8G,EAAO9G,QAC1C/C,EAAAA,EAAAA,GAAaiO,GAAa,SAAApQ,GAAG,OAAIgM,EAAOhM,QACxCmC,EAAAA,EAAAA,GAAakO,GAAgB,SAAArQ,GAAG,OAAIgM,EAAOhM,QAC3CmR,EAAAA,EAAAA,IAAkBpB,GAAY,SAAA7K,GAAM,MAAI,CAAC,GAAD,OAAIA,EAAJ,UAAmB8M,EAAAA,EAAAA,IAAId,EAAMhM,IAAU,QAJ/E,IAKHlB,SAASgO,EAAAA,EAAAA,KAAI7G,EAAAA,EAAAA,IAAS,IAAK,CAAEnL,IAAK,UAAWgK,OAAQ,YAAc2C,EAAY3I,SAE/EoN,gBAAgB1G,EAAAA,EAAAA,KAAIC,EAAAA,EAAAA,IAAIuG,EAAMhO,UAAW+O,EAAAA,IAAMS,EAAAA,MAGjDnG,IAAK,CACHoF,UAAUK,EAAAA,EAAAA,IACRd,EAAMyB,UACNN,EAAAA,EAAAA,IAAO9F,EAAImF,MAAMvP,EAAAA,EAAAA,GAAa6N,GAAU,SAAA0B,GAAI,OAAIR,EAAM,GAAD,OAAIQ,EAAJ,aAAmBgB,EAAAA,KACxEL,EAAAA,EAAAA,IAAO9F,EAAInI,KAAKjC,EAAAA,EAAAA,GAAa2N,GAAa,SAAA1L,GAAG,OAAI8M,EAAM,GAAD,OAAI9M,EAAJ,aAAkBsO,EAAAA,KAE1Ed,QAAQI,EAAAA,EAAAA,IACNd,EAAM0B,YACNP,EAAAA,EAAAA,IAAO9F,EAAInI,KAAKjC,EAAAA,EAAAA,GAAa2N,GAAa,SAAA+C,GAAO,OAAI3B,EAAM,GAAD,OAAI2B,EAAJ,eAAwBC,MAClFT,EAAAA,EAAAA,IAAO9F,EAAImF,MAAMvP,EAAAA,EAAAA,GAAa6N,GAAU,SAAA0B,GAAI,OAAIR,EAAM,GAAD,OAAIQ,EAAJ,eAAqBoB,MAE5EjB,KAAKK,EAAAA,EAAAA,KACHF,EAAAA,EAAAA,IAAIzF,EAAI6B,KAAM7B,EAAIqF,SAClBI,EAAAA,EAAAA,IAAIC,EAAAA,GAAK1F,EAAIoF,WACbU,EAAAA,EAAAA,IAAO9F,EAAIC,QAAS,CAClBD,IAAK0F,EAAAA,GACLc,SAASf,EAAAA,EAAAA,IAAIC,EAAAA,GAAKf,EAAM9N,UACxB4P,QAAQhB,EAAAA,EAAAA,IAAIC,EAAAA,IAAKC,EAAAA,EAAAA,IAAKhB,EAAME,eAAgBF,EAAM9N,YACjD0P,KACH3G,EAAMpJ,KACNsP,EAAAA,EAAAA,IAAO9F,EAAInI,KACTjC,EAAAA,EAAAA,GAAa2N,GAAa,SAAA1L,GAAG,OAAI+H,EAAM,GAAD,OAAI/H,EAAJ,iBAA+B0O,MACvET,EAAAA,EAAAA,IAAOD,EAAmB,CACxBa,MAAMZ,EAAAA,EAAAA,IAAO9F,EAAInI,IAAK,CACpB1C,MAAMwQ,EAAAA,EAAAA,IAAK,GAAGF,EAAAA,EAAAA,IAAID,EAAcb,EAAMgC,YACtCtR,MAAMsQ,EAAAA,EAAAA,IAAK,KAAKF,EAAAA,EAAAA,IAAID,EAAcb,EAAMgC,aACvC,EAAG,CAAElT,IAAK,cACbmT,UAAUd,EAAAA,EAAAA,IAAO9F,EAAInI,IAAK,CACxB5C,OAAO0Q,EAAAA,EAAAA,IAAK,GAAGF,EAAAA,EAAAA,IAAID,EAAcb,EAAMkC,gBACvC1R,MAAMwQ,EAAAA,EAAAA,IAAK,KAAKF,EAAAA,EAAAA,IAAID,EAAcb,EAAMkC,iBACvC,EAAG,CAAEpT,IAAK,mBACZ,KAIPmM,OAAM,QAEJpJ,KAAKoP,EAAAA,EAAAA,KAAKH,EAAAA,EAAAA,IAAI9K,EAAMyE,IAAK,MAAMuG,EAAAA,EAAAA,KAAKF,EAAAA,EAAAA,IAAI7F,EAAM7F,MAAO,MAAM0L,EAAAA,EAAAA,IAAIC,EAAAA,IAAKC,EAAAA,EAAAA,KAAM,EAAG/F,EAAMsF,UAAUO,EAAAA,EAAAA,IAAIC,EAAAA,IAAKC,EAAAA,EAAAA,KAAM,EAAG/F,EAAMa,WACrHyE,OAAQP,EAAMpE,eACXqE,EAAAA,EAAAA,IAAkBrB,GAAa,SAAA1L,GAAG,MACnC,CAAC,GAAD,OAAIA,EAAJ,cAAoBiP,EAAAA,EAAAA,KAAIC,EAAAA,EAAAA,KAAQtB,EAAAA,EAAAA,IAAI7F,EAAM,GAAD,OAAI/H,EAAJ,UAAiB8M,EAAM,GAAD,OAAI9M,EAAJ,gBAAuB,CAAEpE,IAAI,GAAD,OAAKoE,EAAL,SAAiBxF,QAASwF,WAIrHiL,GAAS7B,EAAAA,EAAAA,KAAgBC,EAAAA,EAAAA,IAAUvG,GAAQ,CAAC,WAC5CqM,GAAK,mBACN/F,EAAAA,EAAAA,KAAgBrL,EAAAA,EAAAA,GAAa,GAAD,eAAK2N,IAAL,OAAqB0D,EAAAA,MAAa,SAAAzS,GAAC,OAAIwP,EAAAA,EAAAA,IAAK,UAAS,CAAC,WAD5E,IAETnM,IAAKqP,EAAAA,KAEPF,EAAMnP,IAAM4N,EAAAA,GAAAA,WAAA,UAAOlC,EAAY/P,KAAI,SAAAqE,GAAG,OAAIuG,EAAAA,EAAAA,IAAI4I,EAAMnP,GAAM,QAW1D,IAAMsP,EAAUxM,G,wGCjPT,SAASyM,EAAaC,EAAiCC,EAAiDC,GAC7G,IAAMC,EAAW,IAAIpE,IAA4BqE,EAAU,IAAIrE,IAqB/DiE,EAAS7I,SAnBT,SAASkJ,EAASC,GACZF,EAAQG,IAAID,KAEZH,EAASI,IAAID,GACfjK,QAAQC,MAAM,uDAGhB6J,EAASK,IAAIF,GAEbL,EAAQK,GAERA,EAAQxE,SAAS3E,QAAQkJ,GAEzBH,EAASI,GAETH,EAASM,OAAOH,GAChBF,EAAQI,IAAIF,QAOT,SAASI,EAAYV,EAAiCW,EAAmEC,GAC9H,IAAMT,EAAW,IAAIpE,IACf8E,EAAgB,IAAIC,IACpBC,EAAiB,IAAID,IAE3B,SAASE,EAAMV,GACb,IAAIL,EAAUY,EAAcvO,IAAIgO,GAChC,GAAIL,EAAS,OAAOA,EACpBA,EAAUU,EAAWL,GAErB,IAAIJ,EAAWa,EAAezO,IAAI2N,GAClC,OAAIC,IAEAC,EAASI,IAAIN,IACf5J,QAAQC,MAAM,qDACPiB,EAAAA,EAAAA,IAAS2H,OAElBiB,EAASK,IAAIP,GAEbC,EAAWU,EASb,SAAkBN,GAChB,IAAMxE,EAAWwE,EAAQxE,SAAS3P,IAAI6U,GACtC,OAAOC,EAAWnF,EAAUwE,EAAQxE,UAAYwE,GAAzC,kBAAwDA,GAAxD,IAAiExE,SAAAA,IAXjDuE,CAASJ,GAAUK,GAE1CH,EAASM,OAAOR,GAEhBY,EAAcpJ,IAAI6I,EAASJ,GAC3Ba,EAAetJ,IAAIwI,EAASC,GACrBA,IAQT,IAAMpI,EAASkI,EAAS7T,IAAI6U,GAC5B,OAAOC,EAAWnJ,EAAQkI,GAAYA,EAAWlI,EAuDnD,SAASmJ,EAAcC,EAA6BC,GAClD,YAAU5X,IAAN2X,OAA8B3X,IAAN4X,OAClB5X,IAAN4X,IAEGD,EAAExF,SAAWyF,EAAEzF,QAAUwF,EAAEE,OAAM,SAACxV,EAAOwB,GAAR,OAAcxB,IAAUuV,EAAE/T,S,uLCrH9DiU,EAAkG,CACtGtK,IAAK,SAACjB,GAAD,OAAyBe,KAAKE,IAAL,MAAAF,MAAI,OAAQf,KAC1CgB,IAAK,SAAChB,GAAD,OAAyBe,KAAKC,IAAL,MAAAD,MAAI,OAAQf,KAC1C0K,IAAK,SAAC1K,GAAD,OAAyBA,EAAEwL,QAAO,SAACJ,EAAGC,GAAJ,OAAUD,EAAIC,IAAG,IACxDI,IAAK,SAACzL,GAAD,OAAyBA,EAAEwL,QAAO,SAACJ,EAAGC,GAAJ,OAAUD,EAAIC,IAAG,KAE7CK,GAA2E,kBACnFH,GADmF,IAEtF5B,IAAK,YAA8B,IAA5BA,GAA2B,eAChC,OAAIA,EAAM,EAAU,EAAIA,EAAM,EACrBA,GAAO,IAAa,GAAW,EAANA,EAAU,GACrC,EAAIA,GAEbgC,SAAU,SAAC3L,GAAD,OAAyBA,EAAE,GAAKA,EAAEwL,QAAO,SAACJ,EAAGC,GAAJ,OAAUD,EAAIC,MACjEO,UAAW,+BAAE9V,EAAF,KAAS8V,EAAT,KAAoBC,EAApB,KAA0BC,EAA1B,YAAsDhW,GAAS8V,EAAYC,EAAOC,KAGzFC,EAAgC,IAAI9F,IAAIvN,OAAOtB,KAAKmU,IAEnD,SAASS,EAAS9B,EAAqB+B,GAAyG,IAArFC,EAAoF,uDAAvE,SAACC,GAAD,OAAqD,GAIlI,OADAjC,EAAWkC,EADXlC,EAAWmC,EADXnC,EAAWoC,EAAapC,EAAU+B,EAAcC,KA0GlD,SAASG,EAAQnC,GACf,OAAOU,EAAAA,EAAAA,IAAYV,GAAU,SAAAqC,GAAC,OAAIA,KAAG,SAAAJ,GACnC,IAAInK,EAASmK,EACb,GAAIJ,EAA8BtB,IAAI0B,EAASlM,WAAmB,CAChE,IAAMuK,EAAU2B,EACRlM,EAAcuK,EAAdvK,UAEJuM,GAAY,EACVxG,EAAWwE,EAAQxE,SAASvL,SAAQ,SAAAgS,GAAG,OAC1CA,EAAIxM,YAAcA,GAAcuM,GAAY,EAAMC,EAAIzG,UAAY,CAACyG,MACtEzK,EAASwK,GAAS,kBAAQhC,GAAR,IAAiBxE,SAAAA,IAAawE,EAGlD,OAAOxI,KAGX,SAASoK,EAAYlC,GACnB,SAASwC,EAAiBC,GACxB,IAD6D,EACvD3K,EAAS,IAAIgJ,IAD0C,UAEzC2B,GAFyC,IAE7D,2BAA2B,OAAhB7W,EAAgB,QAAAkM,EAAOL,IAAI7L,GAAO,UAACkM,EAAOxF,IAAI1G,UAAZ,QAAsB,GAAK,IAFX,8BAG7D,OAAOkM,EAcT,IARA,IAAM4K,EAAO,CACX7D,OAAQ,CACN8D,OAAQ,IAAI7B,IACZd,SAAU,IAAIjE,IACdhG,UAAW,QAdoC,aAwBjD,IALA,IAb0B4M,EAatBC,OAAoC,EAElCC,EAAwB,CAAE9M,UAAW2M,EAAK7D,OAAO9I,UAAW+F,UAfxC6G,EAekED,EAAK7D,OAAO8D,QAdjG,OAAIA,GAAQpS,SAAQ,+BAAEgS,EAAF,KAAOO,EAAP,YAAkB7V,MAAM6V,GAAOC,KAAKR,QAgB3DS,EAAwB,IAAIlC,IAChC,MAAwBtS,OAAOtB,KAAKmU,GAApC,gBAAK,IAAMtL,EAAS,KAClBiN,EAAsBvL,IAAI1B,EAAW,IA0EvC,GAxEAiK,GAAWU,EAAAA,EAAAA,IAAYV,GAAU,SAAAiC,GAC/B,GAAIS,EAAK7D,OAAOmB,SAASO,IAAI0B,GAAsB,CACjD,IAAM3B,EAAU2B,EACVgB,EAAkB,IAAInC,IAAI4B,EAAK7D,OAAO8D,QACtC7G,EAAWwE,EAAQxE,SAASE,QAAO,SAAAuG,GACvC,IAAMO,EAAQG,EAAgB3Q,IAAIiQ,GAClC,OAAIO,IACFG,EAAgBxL,IAAI8K,EAAKO,EAAQ,IAC1B,MAKX,OAAKhH,EAASJ,QAEdI,EAAS7E,KAAK4L,IACP,kBAAKvC,GAAZ,IAAqBxE,SAAAA,KAFZ+G,EAIX,OAAOZ,KACN,SAAAA,GACD,IAAKJ,EAA8BtB,IAAI0B,EAASlM,WAAmB,OAAOkM,EAC1E,IAAM3B,EAAU2B,EAEhB,GAAIW,GACF,GAAIA,EAAK7M,YAAcuK,EAAQvK,UAAW,CACxC,IADwC,EAClCmN,EAAgBV,EAAclC,EAAQxE,UAAWqH,EAAe,IAAIrC,IACpEsC,EAAaR,EAAKD,OACpBrF,EAAQ,EAH4B,UAKC4F,EAAclK,WALf,IAKxC,2BAAkE,CAAC,IAAD,uBAAtDqK,EAAsD,KAA1CC,EAA0C,KAC1DC,EAAc1M,KAAKE,IAAIuM,EAAT,UAAuBF,EAAW9Q,IAAI+Q,UAAtC,QAAqD,GACrEE,GACFJ,EAAa1L,IAAI4L,EAAYE,GAC7BjG,GAASiG,GACJJ,EAAa1C,OAAO4C,IAVW,8BAYpC/F,EAAQ,IACVsF,EAAKD,OAASQ,EACdP,EAAK5C,SAASQ,IAAIF,SAGjB,CACL,IADK,EACCkD,EAAaR,EAAsB1Q,IAAIgO,EAAQvK,WAC/C4M,EAASH,EAAclC,EAAQxE,UAFhC,UAIsC0H,GAJtC,IAIL,2BAAuD,CAAC,IAAD,uBAA3CC,EAA2C,KAAhCC,EAAgC,KACjDpG,EAAQ,EAEN6F,EAAe,IAAIrC,IAH4B,UAIV4C,EAAgB1K,WAJN,IAIrD,2BAAsE,CAAC,IAAD,uBAA1DqK,EAA0D,KAA9CM,EAA8C,KAC9Db,EAAQjM,KAAKE,IAAI4M,EAAT,UAAyBhB,EAAOrQ,IAAI+Q,UAApC,QAAmD,GAC7DP,IACFK,EAAa1L,IAAI4L,EAAYP,GAC7BxF,GAASwF,IARwC,8BAWrD,GAAIxF,EAAQ,EAAG,CACbsF,EAAO,CACLD,OAAQQ,EACRnD,SAAU,IAAIjE,IAAI,CAACuE,EAASmD,IAC5B1N,UAAWuK,EAAQvK,WAErBiN,EAAsBY,QACtB,QAtBC,8BAyBAhB,GAAMY,EAAWvM,KAAK,CAACqJ,EAASqC,IAGvC,OAAOrC,MAGLsC,EACC,cADKF,EAAK7D,OAAS+D,KAjFb,kBAkFN,MAGP,OAAO5C,EAOF,SAASoC,EAAapC,EAAqB+B,GAAyG,IAArFC,EAAoF,uDAAvE,SAACC,GAAD,OAAqD,GAEhI1G,EAAkB,CAAExK,KAAM,GAAI8S,UAAW,IAAI/C,KAC7CgD,EAAiB,IAAIhD,IAAI,CAAC,CAACvF,EAAQ,IAAIuF,OAK7C,SAASiD,EAAKzD,EAA4B0D,GAAsC,IAAD,EACvEC,EAAMD,EAAQH,UAAUvR,IAAIgO,GAClC,GAAI2D,EAAK,OAAOA,EAEhB,IACInM,EADI/B,EAAcuK,EAAdvK,UAER,OAAQA,GACN,IAAK,QAAS,OAAOuK,EACrB,IAAK,MAAO,IAAK,MAAO,IAAK,MAAO,IAAK,MACvC,IAAM+B,EAAIb,EAAczL,GAClBmO,EAA4B,GAC5BC,EAA6B7D,EAAQxE,SAASE,QAAO,SAAAsE,GACzD,IAAM8D,EAASL,EAAKzD,EAAS0D,GAC7B,MAA6B,UAArBI,EAAOrO,YACVmO,EAAgBjN,KAAKmN,EAAOxY,QAAQ,MAExCO,KAAI,SAAA2J,GAAC,OAAIiO,EAAKjO,EAAGkO,MACdK,EAAehC,EAAE6B,GAcvB,GAAKI,SAASD,IAOP,GAAkB,QAAdtO,GAAwC,IAAjBsO,EAAoB,CACpDvM,GAASP,EAAAA,EAAAA,IAAS8M,GAClB,YARA,GAAmB,QAAdtO,IACY,QAAdA,GAAuBsO,EAAe,KACxB,QAAdtO,GAAuBsO,EAAe,GAAI,CAC3CvM,GAASP,EAAAA,EAAAA,IAAS8M,GAClB,MAOAA,IAAiBhC,EAAE,KACrB8B,EAAgBlN,MAAKM,EAAAA,EAAAA,IAAS8M,IACCvM,EAA7BqM,EAAgBzI,QAAU,EAAS,UAAGyI,EAAgB,UAAnB,SAAyB5M,EAAAA,EAAAA,IAAS8K,EAAE,KAC7D,CAAEtM,UAAAA,EAAW+F,SAAUqI,GACrC,MACF,IAAK,MAAO,IAAK,WACf,IAAMrI,EAAWwE,EAAQxE,SAAS3P,KAAI,SAAA2J,GAAC,OAAIiO,EAAKjO,EAAGkO,MAC7C3B,EAAIb,EAAczL,GAEtB+B,EADEgE,EAASsF,OAAM,SAAAtL,GAAC,MAAoB,UAAhBA,EAAEC,cACfwB,EAAAA,EAAAA,IAAS8K,EAAEvG,EAAS3P,KAAI,SAAA2J,GAAC,OAAKA,EAA2BlK,YACzD,kBAAQ0U,GAAR,IAAiBxE,SAAAA,IAC5B,MAEF,IAAK,SACH,IAAMyI,EAAQR,EAAKzD,EAAQxE,SAAS,GAAIkI,GACxC,GAAwB,UAApBO,EAAMxO,UAAuB,CAAC,IAAD,EACzB1J,EAAQ,UAAGiU,EAAQkE,MAAMD,EAAM3Y,cAAvB,QAAkC0U,EAAQxE,SAAS,GACjE,GAAIzP,EAAU,CACZyL,EAASiM,EAAK1X,EAAU2X,GACxB,OAGJ,MAAM,IAAIS,MAAJ,sBAAyB1O,EAAzB,wBAER,IAAK,OACH,IAAM2O,EAAQpE,EAAQxE,SAAS6I,MAAK,SAAAC,GAClC,IAAMR,EAASL,EAAKa,EAAIZ,GACxB,GAAyB,UAArBI,EAAOrO,UACT,MAAM,IAAI0O,MAAJ,sBAAyB1O,EAAzB,wBACR,YAAwBxM,IAAjB6a,EAAOxY,SAEhBkM,EAAS4M,EAAQX,EAAKW,EAAOV,IAAWzM,EAAAA,EAAAA,SAAShO,GACjD,MAEF,IAAK,QAAU,IAAD,IACRsb,OAAWtb,EADH,UAEU+W,EAAQxE,UAFlB,IAEZ,2BAAwC,CAAC,IAAD,EAChCsI,EAASL,EADuB,QACTC,GAC7B,GAAyB,UAArBI,EAAOrO,UACT,MAAM,IAAI0O,MAAJ,sBAAyB1O,EAAzB,8BACgBxM,KAAZ,QAAR,EAAAsb,SAAA,eAAUjZ,aAAyCrC,IAAjB6a,EAAOxY,OAAuBwY,EAAOxY,MAAQiZ,EAASjZ,SAC1FiZ,EAAWT,IAPH,8BASZtM,EAAM,UAAG+M,SAAH,SAAetN,EAAAA,EAAAA,SAAShO,GAC9B,MAEF,IAAK,QACH,MAAiC+W,EAAQxE,SAAS3P,KAAI,SAAC2J,GAAD,OAA0BiO,EAAKjO,EAAGkO,MAAxF,eAAOc,EAAP,KAAWC,EAAX,KAAeC,EAAf,KAAsBC,EAAtB,KACA,GAAqB,UAAjBH,EAAG/O,WAA0C,UAAjBgP,EAAGhP,UACjC,MAAM,IAAI0O,MAAJ,sBAAyB1O,EAAzB,wBACR+B,EAAUgN,EAAGlZ,QAAUmZ,EAAGnZ,MAASoZ,EAAQC,EAC3C,MAEF,IAAK,YACH,MAAuC3E,EAAQxE,SAAS3P,KAAI,SAAA2J,GAAC,OAAIiO,EAAKjO,EAAGkO,MAAzE,eAAOpY,EAAP,KAAc8V,EAAd,KAAyBC,EAAzB,KAA+BC,EAA/B,KAEE9J,EADsB,UAApBlM,EAAMmK,WAAiD,UAAxB2L,EAAU3L,UAClCnK,EAAMA,OAAS8V,EAAU9V,MAAQ+V,EAAOC,GAE3C,kBAAQtB,GAAR,IAAiBxE,SAAU,CAAClQ,EAAO8V,EAAWC,EAAMC,KAC5D,MAEF,IAAK,YACH,MAAgBtB,EAAQxE,SAAS3P,KAAI,SAAA2J,GAAC,OAAIiO,EAAKjO,EAAGkO,MAA3CO,GAAP,eACAzM,EAA8B,UAApByM,EAAMxO,WACZwB,EAAAA,EAAAA,IAAS+I,EAAQ4E,KAAKX,EAAM3Y,SADvB,QAAC,UAED0U,GAFA,IAESxE,SAAU,CAACyI,KAC7B,MAEF,IAAK,OACH,IAAMzI,EAAWkI,EAAQjT,KACtB5E,KAAI,SAAA2J,GAAC,OAAIK,EAAAA,EAAAA,IAAaL,EAAGwK,EAAQhL,SACjC0G,QAAO,SAAAlG,GAAC,OAAIA,KAEf,GAAwB,IAApBgG,EAASJ,OACX,GAAIsG,EAAW1B,GAAU,CACvB,IAAQ1F,EAAS0F,EAAT1F,KAEN9C,OADWvO,IAATqR,GAA+B,UAATA,EACE,WAAjB0F,EAAQ1E,MAAoBrE,EAAAA,EAAAA,SAAShO,IAAagO,EAAAA,EAAAA,IAAS2H,MACxD3H,EAAAA,EAAAA,IAASiK,EAAc5G,GAAM,UACtC9C,EAASwI,OAEhBxI,OAD0BvO,IAAjB+W,EAAQ1F,MAA0C,IAApBkB,EAASJ,OACvCqI,EAAKjI,EAASA,EAASJ,OAAS,GAAIsI,GAEpCD,EAAK,CAAEhO,UAAWuK,EAAQ1F,KAAMkB,SAAAA,GAAyCkI,GACpF,MAEF,IAAK,OACC1D,EAAQ6E,QAAOnB,EAAUzI,GAC7B,IAAMpP,EAAM2X,EAAexR,IAAI0R,GAC3BoB,EAAcjZ,EAAImG,IAAIgO,EAAQvP,MAC7BqU,IACHA,EAAc,CAAErU,KAAK,GAAD,eAAMiT,EAAQjT,MAAd,CAAoBuP,EAAQvP,OAAO8S,UAAW,IAAI/C,KACtEgD,EAAerM,IAAI2N,EAAa,IAAItE,KACpC3U,EAAIsL,IAAI6I,EAAQvP,KAAMqU,IAExBtN,EAASiM,EAAKzD,EAAQxE,SAAS,GAAIsJ,GACnC,MACF,SAASC,EAAAA,EAAAA,IAAkBtP,GAI7B,OADAiO,EAAQH,UAAUpM,IAAI6I,EAASxI,GACxBA,EAGT,IAAMkM,EAAU,CAAEjT,KAAM,CAACgR,GAAe8B,UAAW,IAAI/C,KAGvD,OAFAgD,EAAerM,IAAIuM,EAAS,IAAIlD,KAChCgD,EAAexR,IAAIiJ,GAAS9D,IAAIsK,EAAciC,GACvChE,EAAS7T,KAAI,SAAA2J,GAAC,OAAIiO,EAAKjO,EAAGkO,Q,wNCxZ7BsB,GAAa,EAaN9J,EAAb,WAWE,WAAYzK,EAAYwU,IAA6B,oBAVrDhK,YAUoD,OATpDlT,SAAW,IAAIyY,IASqC,KAPpD/P,UAOoD,OANpDyU,MAAQ,IAAI1E,IAMwC,KALpD+C,UAAY,IAAI/C,IAKoC,KAHpD/W,aAAeR,EAGqC,KAFpDoQ,cAAgBpQ,OAGDA,IAATwH,GAEFY,KAAKZ,KAAO,GACZY,KAAK4J,OAAS5J,OAET4T,IACHA,EAAS,IAAI/J,OAAOjS,OAAkBA,IAExCoI,KAAKZ,KAAL,CAAaA,GAAb,eAAsBwU,EAAOxU,OAC7BY,KAAK4J,OAASgK,EAAOhK,QArB3B,yCAyBE,WAIE,OADK5J,KAAK5H,UAAS4H,KAAK5H,QAAU4H,KAAK8T,OAAO,CAAC,aACxC9T,KAAK5H,UA7BhB,yBA+BE,WACE,IAAK4H,KAAKgI,SAAU,CAClB,IAAM+L,EAAa/T,KAAK8T,OAAO,CAAC,aAAc3N,EAAS,IAEvDjC,EAAAA,EAAAA,IAAYiK,EAAAA,GAAS,IAAI,SAAChK,GAAD,OAAYA,EAAEC,aAAW,SAACD,EAAwCR,GACzF,IAAMqQ,GAAOxP,EAAAA,EAAAA,IAAauP,EAAY5P,EAAER,MACpCqQ,IAAMrM,EAAAA,EAAAA,IAAkBxB,EAAQxC,EAAMqQ,MAE5ChU,KAAKgI,SAAW7B,EAElB,OAAOnG,KAAKgI,WAzChB,oBA2CE,SAAOvD,GAAwB,IAAD,SACtB0B,EAAS,GADa,UAETnG,KAAKZ,MAFI,IAE5B,2BAA8B,CAAC,IAAD,EAAnBA,EAAmB,SAC5B8E,EAAAA,EAAAA,IAAW,WAACM,EAAAA,EAAAA,IAAapF,EAAMqF,UAApB,QAA+B,GAAI,IAAI,SAACN,GAAD,OAAYA,EAAEC,aAC9D,SAACD,EAAY1J,GAAb,OAA+BkN,EAAAA,EAAAA,IAAkBxB,EAAQ1L,EAAK,EAAKkG,IAAIwD,QAJ/C,8BAM5B,OAAOgC,IAjDX,iBAsDE,SAAI6N,GACF,QAAapc,IAAToc,EAEF,OADAtP,QAAQuP,MAAM,0CACP,CAAE5P,KAAM,GAAID,WAAW,EAAMnK,WAAOrC,EAAWsc,SAAS,EAAMC,KAAM,GAAI9F,SAAU,IAE3F,IAAMiE,EAAMtS,KAAKkS,UAAUvR,IAAIqT,GAC/B,GAAI1B,EAAK,OAAOA,EAEhB,IAAMnM,EAuOV,SAA+B6N,GAC7B,IAAQ3P,EAA0D2P,EAA1D3P,KAAM+P,EAAoDJ,EAApDI,aAAcna,EAAsC+Z,EAAtC/Z,MAAO0U,EAA+BqF,EAA/BrF,QAAS0F,EAAsBL,EAAtBK,WAAYC,EAAUN,EAAVM,MACxD,MAAO,CACLlQ,WAAW,EACXC,KAAAA,EACApK,MAAAA,EACAia,QAASI,EACTH,KAAMI,EAAAA,GAAAA,KAAYlQ,EAAK5J,KACvBkU,QAAAA,EAASN,SAAS,GAAD,eAAOgG,EAAa,CAACA,GAAc,KAAnC,OAA2CD,KA/O7CI,CAAmBxU,KAAKyU,YAAYT,IAEnD,OADAhU,KAAKkS,UAAUpM,IAAIkO,EAAM7N,GAClBA,IAhEX,yBAqEE,SAAoB6N,GAClB,IAAM1B,EAAMtS,KAAK6T,MAAMlT,IAAIqT,GAC3B,GAAI1B,EAAK,OAAOA,EAEhB,IACInM,EADI/B,EAAoB4P,EAApB5P,UAAWC,EAAS2P,EAAT3P,KAEnB,OAAQD,GACN,IAAK,MAAO,IAAK,MAAO,IAAK,MAAO,IAAK,MACzC,IAAK,MAAO,IAAK,WACf+B,EAASnG,KAAK0U,SAASV,GAAO,MAChC,IAAK,YAAa7N,EAASnG,KAAK2U,WAAWX,GAAO,MAClD,IAAK,QAAS7N,EAASnG,KAAK4U,UAAUZ,EAAK/Z,OAAQ,MACnD,IAAK,YAAakM,EAASnG,KAAK6U,WAAWb,GAAO,MAClD,IAAK,OAAQ7N,EAASnG,KAAK8U,MAAMd,GAAO,MACxC,IAAK,OAAQ7N,EAASnG,KAAK+U,MAAMf,GAAO,MACxC,IAAK,QAAS7N,EAASnG,KAAKgV,OAAOhB,GAAO,MAC1C,IAAK,SAAU7N,EAASnG,KAAKiV,QAAQjB,GAAO,MAC5C,IAAK,OAAQ7N,EAASnG,KAAKkV,MAAMlB,EAAK7J,UAAW,MACjD,IAAK,QAAShE,EAASnG,KAAKmV,OAAOnB,EAAK7J,UAAW,MACnD,SAASuJ,EAAAA,EAAAA,IAAkBtP,GAG7B,GAAIC,EAAM,CACR,IAAQiF,EAAYjF,EAAZiF,SACRnD,GAAM,UAAQA,IACP9B,KAoQb,SAAmBwE,EAAYuM,GAE7B,IADA,IAAMjP,GAAM,UAAQ0C,GACpB,MAA2BhM,OAAOwK,QAAQ+N,GAA1C,gBAAK,sBAAO3a,EAAP,KAAYR,EAAZ,KACCA,IAAOkM,EAAO1L,GAAOR,GAC3B,OAAOkM,EAxQWkP,CAAUlP,EAAO9B,KAAMA,GAKjCiF,WACKnD,EAAOwI,eACPxI,EAAOkO,WACdlO,EAAOiO,aAAe,IAAIhK,MAExBjE,EAAO9B,KAAKqF,OAAUvD,EAAOwI,UAC/BxI,EAAOmP,iBAAkB,GAK7B,OAoMJ,SAAuBtB,GACrB,IAAQ3P,EAAyB2P,EAAzB3P,KAAMpK,EAAmB+Z,EAAnB/Z,MAAO0U,EAAYqF,EAAZrF,QACblU,EAAwC4J,EAAxC5J,IAAKgK,EAAmCJ,EAAnCI,OAAQR,EAA2BI,EAA3BJ,OAAQ5K,EAAmBgL,EAAnBhL,QAASkc,EAAUlR,EAAVkR,MACtC,GAAqB,kBAAVtb,EAAoB,OAE/B,GADA+Z,EAAKwB,cAAe,SAAC,IAAD,CAAWvf,MAAM,OAAjB,UAAyBwf,EAAAA,EAAAA,IAAYxb,EAAOsa,EAAAA,GAAAA,KAAY9Z,GAAM8a,KAC9E9a,GAAe,MAARA,EAAa,CACtB,IAAMib,EAAiBjR,IAAWR,GAAU,gCAAGsQ,EAAAA,GAAAA,aAAoB9P,GAAvB,QAAsC,wBAE5EkR,EAAgB1R,GAAS,UAAC,IAAD,CAAWhO,MAAM,YAAjB,eAAgCgO,EAAhC,OAAuD,KACtF+P,EAAK9b,MAAO,iCAAE,UAAC,IAAD,CAAWjC,MAAOoD,EAAlB,UAA4Bqc,EAAenB,EAAAA,GAAAA,IAAW9Z,MAAmBkb,KAEnFhH,IACFqF,EAAKK,YAAa,iBAAKxd,GAAG,UAAR,UAAmBmd,EAAK9b,KAAxB,IAA+B8b,EAAKwB,aAApC,MAAqD7G,OAnNzEiH,CAAczP,GAEdnG,KAAK6T,MAAM/N,IAAIkO,EAAM7N,GACdA,IA9GX,wBAiHE,SAAmBxC,GACjB,OAAO3D,KAAKZ,KAAK5E,KAAI,SAAA2J,GAAC,OAAIK,EAAAA,EAAAA,IAAaL,EAAGR,MAA4B0G,QAAO,SAAAlG,GAAC,OAAIA,OAlHtF,uBAoHE,SAAkBR,GAChB,IAAMvE,EAAOY,KAAKZ,KAAK5E,KAAI,SAAA2J,GAAC,OAAIK,EAAAA,EAAAA,IAAaL,EAAGR,MAA4BqP,MAAK,SAAA7O,GAAC,OAAIA,KACtF,OAAO/E,GAAQY,KAAKyU,YAAYrV,KAtHpC,mBAyHE,SAAcyU,GAAoE,IAAD,OACzEd,EAAQc,EAAMb,MAAK,SAAAgB,GAAI,YAAqCpc,IAAjC,EAAK6c,YAAYT,GAAM/Z,SACxD,OAAO8Y,EAAQ/S,KAAKyU,YAAY1B,GAAS8C,IA3H7C,oBA6HE,SAAehC,GAAoE,IAAD,IAC5EX,OAA+Dtb,EADa,UAE7Dic,GAF6D,IAEhF,2BAA0B,CAAC,IAAD,EAAfG,EAAe,QAClBlC,EAAY9R,KAAKyU,YAAYT,SACXpc,KAAZ,QAAR,EAAAsb,SAAA,eAAUjZ,QAAwB6X,EAAU7X,OAAS6X,EAAU7X,MAAQiZ,EAASjZ,SAClFiZ,EAAWpB,IALiE,8BAOhF,iBAAOoB,SAAP,QAAmB2C,IApIvB,mBAsIE,SAAc7B,GAA+F,IAE9E,EAF6E,OAClGrQ,EAASqQ,EAATrQ,KACR,QAAkB/L,IAAdoc,EAAK/K,KACP,iBAAOjJ,KAAK8V,UAAUnS,UAAtB,QAA8C,WAAdqQ,EAAK/J,KAAoB4L,EAAeE,EAExE,IAAMlC,EAAQ7T,KAAKgW,WAAWrS,GAC9B,OAAqB,IAAjBkQ,EAAM9J,OAAqB/J,KAAKyU,YAAYZ,EAAM,IACjC,UAAdG,EAAK/K,KACRjJ,KAAKmV,OAAOtB,GACZ7T,KAAKiW,YAAYjC,EAAK/K,KAAM4K,EAAMrZ,KAAI,SAAA2J,GAAC,OAAI,EAAKsQ,YAAYtQ,SA/ItE,qBAkJE,SAAgB6P,GAAuF,IAAD,EAC9FvZ,EAAMuF,KAAKyU,YAAYT,EAAK7J,SAAS,IAAIlQ,MACzCS,EAAQ,UAAGsZ,EAAKnB,MAAMpY,UAAd,QAAuBuZ,EAAK7J,SAAS,GACnD,IAAKzP,EACH,MAAM,IAAIoY,MAAJ,+BAAkCrY,IAC1C,OAAOuF,KAAKyU,YAAY/Z,KAvJ5B,oBAyJE,SAAesZ,GACb,cAAiDA,EAAK7J,SAAtD,GAAO+L,EAAP,KAAeC,EAAf,KAAuBC,EAAvB,KAAkCC,EAAlC,KACMlD,EAAKnT,KAAKyU,YAAYyB,GAAS9C,EAAKpT,KAAKyU,YAAY0B,GACrDG,EAAWnD,EAAGlZ,QAAUmZ,EAAGnZ,MAC7BkM,EAASnG,KAAKyU,YAAY6B,EAAWF,EAAYC,GACrD,OAASC,GAA6B,UAAjBtC,EAAKuC,UAA0BD,GAA6B,YAAjBtC,EAAKuC,QACjEC,EAAUrQ,EAAOlM,OAASkM,IA/JlC,wBAiKE,SAAmB6N,GACjB,cAA+CA,EAAK7J,SAApD,GAAOsM,EAAP,KAAkBC,EAAlB,KAAiC1G,EAAjC,KAAuCC,EAAvC,KACMhW,EAAQ+F,KAAKyU,YAAYgC,GAAY1G,EAAY/P,KAAKyU,YAAYiC,GAClEvQ,EAASlM,EAAMA,OAAS8V,EAAU9V,MAAQ+F,KAAKyU,YAAYzE,GAAQhQ,KAAKyU,YAAYxE,GAC1F,OAAQhW,EAAMA,OAAS8V,EAAU9V,MACX,OAAjB+Z,EAAKuC,QAAmBC,EAAUrQ,EAAOlM,OAASkM,EACjC,MAAjB6N,EAAKuC,QAAkBC,EAAUrQ,EAAOlM,OAASkM,IAvK1D,mBAyKE,SAAc6N,GACZ,IAAI2C,EAAQ3W,KAAKtJ,SAASiK,IAAIqT,EAAK5U,MAKnC,OAJKuX,IACHA,EAAQ,IAAI9M,EAAOmK,EAAK5U,KAAM4U,EAAKR,MAAQxT,KAAK4J,OAAS5J,MACzDA,KAAKtJ,SAASoP,IAAIkO,EAAK5U,KAAMuX,IAExBA,EAAMlC,YAAYT,EAAK7J,SAAS,MA/K3C,sBAiLE,SAAiB6J,GAAwC,IAAD,OAC9C5P,EAAwB4P,EAAxB5P,UAAW+F,EAAa6J,EAAb7J,SACnB,OAAOnK,KAAKiW,YAAY7R,EAAW+F,EAAS3P,KAAI,SAAA2J,GAAC,OAAI,EAAKsQ,YAAYtQ,SAnL1E,wBAqLE,SAAmB6P,GAAkD,IAAD,EAC5D4C,EAAU5W,KAAKyU,YAAYT,EAAK7J,SAAS,IACzClQ,EAAK,UAAG+Z,EAAKT,KAAKqD,EAAQ3c,cAArB,QAA+BsT,IAC1C,OAAOvN,KAAK4U,UAAU3a,KAxL1B,uBA0LE,SAAqBA,GACnB,MAAO,CACLoK,KAAM,GAAIpK,MAAAA,EACVqa,OAAO,EACPgB,iBAAiB,EACjBlB,aAAc,IAAIhK,OA/LxB,yBAkME,SAAoBhG,EAAqC+F,GAAqD,IAAD,IACvG9Q,EAgBAsV,EAfJ,OAAQvK,GACN,IAAK,MAAO,IAAK,MAAO,IAAK,MAAO,IAAK,MACzC,IAAK,MAAO,IAAK,WACf/K,EAqFR,SAA0B8Q,GACxB,IAAM0M,EAAS,IAAIzM,IAAID,EAAS3P,KAAI,SAAA2J,GAAC,OAAIA,EAAEE,KAAKhL,YAC5Cwd,EAAO1e,KAAO,GAAG0e,EAAO/H,YAAOlX,GAC/Bif,EAAO1e,KAAO,GAAG0e,EAAO/H,OAAO,YAEnC,OAAI+H,EAAOjI,IAAI,QAAgB,OAC3BiI,EAAOjI,IAAI,YAAoB,WAC5BiI,EAAOrT,SAASyN,OAAOhX,MA5Fd6c,CAAc3M,GAAW,MACrC,SAASuJ,EAAAA,EAAAA,IAAkBtP,GAE7B,OAAQA,GACN,IAAK,MAAO,IAAK,MAAO,IAAK,MAAO,IAAK,MACvC,IAAM2S,EAAWlH,EAAAA,GAAczL,GAAW,IAG1C,KADE+F,EAAWA,EAASE,QAAO,SAAAuM,GAAO,OAAIA,EAAQ3c,QAAU8c,MAC5ChN,OACZ,OAAO1Q,GAAO,kBAAQ2G,KAAK4U,UAAUmC,IAAvB,IAAkC1S,KAAM,CAAEhL,QAAAA,KAAc2G,KAAK4U,UAAUmC,GAI3F,IAAIzB,GAAkB,EACtB,OAAQlR,GACN,IAAK,MAAOuK,EAAUqI,EAAH,+BAAe,CAAE7M,SAAAA,IAAgB,MACpD,IAAK,MAAOwE,EAAUqI,EAAH,+BAAe,CAAE7M,SAAAA,IAAgB,MACpD,IAAK,MAAOwE,EAAUqI,EAAH,wBAAU,CAAE7M,SAAAA,EAAU8M,UAAW,QAAW,MAC/D,IAAK,MAAOtI,EAAUqI,EAAH,wBAAU,CAAE7M,SAAAA,EAAU8M,UAAW,MAAOtD,WAAYxJ,EAASJ,OAAS,IAAO,MAChG,IAAK,WAAY4E,EAAUqI,EAAH,kCAAU,CAAE7M,SAAU,CAACA,EAAS,IAAKwJ,WAAAA,GAAoB,CAAExJ,SAAAA,EAAU8M,UAAW,QAAa,MACrH,IAAK,MACH,IAAMpO,EAAOsB,EAAS,GAAGlQ,MACrB4O,EAAO,GACT8F,EAAUqI,EAAH,mCAAiB,CAAE7M,SAAAA,EAAUwJ,WAAAA,IACpC2B,GAAkB,GAEXzM,GAAQ,IAAM8F,EAAUqI,EAAH,8CAAmB,CAAE7M,SAAAA,EAAUwJ,WAAAA,KAE3DhF,EAAUqI,EAAH,+BAAiB,CAAE7M,SAAAA,EAAUwJ,WAAAA,IACpC2B,GAAkB,GAEpB,MAEF,SAAS5B,EAAAA,EAAAA,IAAkBtP,GAE7B,OAAQA,GACN,IAAK,MAAO,IAAK,MACX+F,EAASJ,QAAU,EAAGuL,EAAe,oBAAGnL,EAAS,UAAZ,aAAG,EAAamL,uBAAhB,SAClB,QAAdlR,IAAqBkR,GAAkB,GAGpD,IAAMrb,EAAQ4V,EAAAA,GAAczL,GAAW+F,EAAS3P,KAAI,SAAA2J,GAAC,OAAIA,EAAElK,UACrDma,EAAe,IAAIhK,KAAJ,OAAYD,EAASvL,SAAQ,SAAAuF,GAAC,OACjDA,EAAEE,KAAKqF,OAASvF,EAAEkQ,WAAlB,CACKlQ,EAAEkQ,YADP,eACsBlQ,EAAEiQ,gBADxB,OAEQjQ,EAAEiQ,mBAOZ,MANmC,CACjC/P,KAAM,CAAEhL,QAAAA,GACRsV,QAASA,EAAQvW,QACjBkc,MAAOnK,EAASsF,OAAM,SAAAtL,GAAC,OAAIA,EAAEmQ,SAC7Bra,MAAAA,EAAOqb,gBAAAA,EAAiBlB,aAAAA,OAzP9B,KA+PA,SAAS4C,EAAKE,GAA0H,IAAD,uBAAvF3D,EAAuF,iCAAvFA,EAAuF,kBACrI,IAAMa,EAAe,IAAIhK,IACnB+M,EAA4B,GAyBlC,OAvBAD,EAAQ1R,SAAQ,SAAC4R,EAAQ3b,GACvB0b,EAAW7R,KAAK8R,GAEhB,IAAM3c,EAAM8Y,EAAK9X,GACjB,GAAIhB,EAAK,CACP,IAAQ0P,EAA2C1P,EAA3C0P,SAAUwJ,EAAiClZ,EAAjCkZ,WAAlB,EAAmDlZ,EAArBwc,UAAAA,OAA9B,MAA0C,KAA1C,EACA9M,EAAS3E,SAAQ,SAAC6R,EAAM5b,EAAGqV,GACzB,IAAIwG,EACkCA,GAAjCD,EAAKhT,KAAKqF,OAAS2N,EAAK1I,QAAuB0I,EAAK1I,QACtC4I,EAAuBF,GAEtC1D,GAAc0D,EAAK/B,iBACrB6B,EAAW7R,KAAK,MAChB6R,EAAW7R,KAAKgS,GAChBH,EAAW7R,KAAK,OAEhB6R,EAAW7R,KAAKgS,GAEd7b,EAAI,EAAIqV,EAAM/G,QAAQoN,EAAW7R,KAAK2R,GAC1CI,EAAKjD,aAAa5O,SAAQ,SAAArB,GAAC,OAAIiQ,EAAavF,IAAI1K,aAI/C,CAAE/L,QAASof,EAAuBL,GAAa/C,cAAa,OAAKA,IAuC1E,SAASmD,EAAuBvD,GAC9B,IAAQ9b,EAAuB8b,EAAvB9b,KAAMsd,EAAiBxB,EAAjBwB,aAEd,OAAOtd,GAAO,iCAAE,iBAAMuf,MAAO,CAAEC,SAAU,OAAzB,SAAmCxf,IAArC,IAAmDsd,KAAmBA,EAEtF,SAASgC,EAAuBG,GAC9B,OAAO,8BAAGA,EAAWnd,KAAI,SAAC2J,EAAG1I,GAAJ,OAAU,0BAAe0I,GAAJ1I,QAkDhD,IAAMsa,EAAgC,CACpC1R,KAAM,CAAEqF,OAAO,GACfzP,MAAOsT,IACP+G,OAAO,EACPF,aAAc,IAAIhK,IAClBkL,iBAAiB,GAEbO,EAAuD,CAC3DxR,KAAM,CAAEqF,OAAO,GACfzP,WAAOrC,EACP0c,OAAO,EACPF,aAAc,IAAIhK,IAClBkL,iBAAiB,GAKnB,SAASkB,EAAUoB,GACjB,MAAO,CACLvT,KAAM,GAAIpK,MAAO2d,EAAYtD,OAAO,EAAMF,aAAc,IAAIhK,IAAOkL,iBAAiB,K,2vBCxZ3EpH,EAAgBtI,EAAS2H,IAAK,CAAE9S,IAAK,SACrCiS,EAAM/G,EAAQ,GAAIwH,EAASxH,EAAQ,GAKzC,SAASC,EAAS3L,EAAoCoK,GAC3D,MAAO,CAAED,UAAW,QAAS+F,SAAU,GAAIlQ,MAAAA,EAAOoK,KAAAA,GAG7C,SAASsB,EAAQ1L,EAAeoK,GAGrC,OAFIpK,GAAS4d,OAAOC,UAAY,MAAK7d,EAAQ8d,EAAAA,GACzC9d,IAAU4d,OAAOC,UAAY,MAAK7d,GAAS8d,EAAAA,GACxCnS,EAAS3L,GAAD,QAAUQ,IAAK,KAAQ4J,IAKjC,SAAS0J,EAAQiG,EAAyB3P,GAE/C,OADIA,IAAM2P,EAAK3P,MAAL,kBAAiB2P,EAAK3P,MAASA,IAClC2P,EAMF,SAASlH,EAAO8F,EAAgBC,EAA8BmF,EAAwB3T,GAE3F,MAAO,CAAED,UAAW,SAAU+F,SADA,SAAb6N,EAAsB,CAACC,EAAMrF,GAAQqF,EAAMD,IAAsB,CAACC,EAAMrF,IACjDC,MAAAA,EAAOxO,KAAAA,GAI1C,SAASe,IAAgC,IAAD,uBAAxB5B,EAAwB,yBAAxBA,EAAwB,gBAC7C,MAAO,CAAEY,UAAW,MAAO+F,SAAU+N,EAAQ1U,IAGxC,SAAS2B,IAAgC,IAAD,uBAAxB3B,EAAwB,yBAAxBA,EAAwB,gBAC7C,MAAO,CAAEY,UAAW,MAAO+F,SAAU+N,EAAQ1U,IAGxC,SAASiJ,IAAgC,IAAD,uBAAxBjJ,EAAwB,yBAAxBA,EAAwB,gBAC7C,MAAO,CAAEY,UAAW,MAAO+F,SAAU+N,EAAQ1U,IAGxC,SAASmJ,IAAiC,IAAD,uBAAxBnJ,EAAwB,yBAAxBA,EAAwB,gBAC9C,MAAO,CAAEY,UAAW,MAAO+F,SAAU+N,EAAQ1U,IAGxC,SAASoJ,EAAKzI,EAAQtD,GAC3B,MAAO,CAAEuD,UAAW,WAAY+F,SAAU+N,EAAQ,CAAC/T,EAAGtD,KAEjD,SAASiN,EAAIjF,GAClB,MAAO,CAAEzE,UAAW,MAAO+F,SAAU+N,EAAQ,CAACrP,KAMzC,SAASsP,EAAMhF,EAAeC,EAAepD,EAAW3L,GAC7D,MAAO,CAAED,UAAW,QAAS+F,SAAU,CAAC8N,EAAM9E,GAAK8E,EAAM7E,GAAK6E,EAAMjI,GAAOiI,EAAM,IAAK5T,KAAAA,EAAMkS,QAAS,WAKhG,SAAStJ,EAASkG,EAAeC,EAAepD,EAAW3L,GAChE,MAAO,CAAED,UAAW,QAAS+F,SAAU,CAAC8N,EAAM9E,GAAK8E,EAAM7E,GAAK6E,EAAMjI,GAAOiI,OAAMrgB,IAAayM,KAAAA,EAAMkS,QAAS,WAKxG,SAAS6B,EAAQjF,EAAeC,EAAepD,EAAiB3L,GACrE,MAAO,CAAED,UAAW,QAAS+F,SAAU,CAAC8N,EAAM9E,GAAK8E,EAAM7E,GAAK6E,EAAM,GAAIA,EAAMjI,IAAQ3L,KAAAA,EAAMkS,QAAS,SAIhG,SAAS7U,EAAUyR,EAASC,EAASpD,EAAW3L,GAErD,MAAO,CAAED,UAAW,YAAa+F,SADhB,CAAC8N,EAAM9E,GAAK8E,EAAM7E,GAAK6E,EAAMjI,GAAOiI,EAAM,IAChB5T,KAAAA,EAAMkS,QAAS,KAIrD,SAAS8B,EAAalF,EAASC,EAASpD,EAAW3L,GAExD,MAAO,CAAED,UAAW,YAAa+F,SADhB,CAAC8N,EAAM9E,GAAK8E,EAAM7E,GAAK6E,EAAMjI,GAAOiI,OAAMrgB,IAChByM,KAAAA,EAAMkS,QAAS,KAIrD,SAAS+B,EAASnF,EAASC,EAASpD,EAAiB3L,GAE1D,MAAO,CAAED,UAAW,YAAa+F,SADhB,CAAC8N,EAAM9E,GAAK8E,EAAM7E,GAAK6E,EAAM,GAAIA,EAAMjI,IACb3L,KAAAA,EAAMkS,QAAS,MAGrD,SAAStO,EAAoCsQ,GAAwC,IAA3B9T,EAA0B,uDAAP,GAClF,GAAI8T,EAASnU,UAAW,CACtB,GAA2B,SAAvBmU,EAASnU,UACX,MAAM,IAAI0O,MAAJ,gBAAoByF,EAAiBnU,UAArC,8BACR,OAAO,kBAAKmU,GAAZ,IAAsB5U,KAAMc,IAE5B,OAAO7H,EAAAA,EAAAA,GAAaC,OAAOtB,KAAKgd,IAAW,SAAA9d,GAAG,OAC5CwN,EAAgBsQ,EAAS9d,GAAV,kBAAoBgK,GAApB,CAA4BhK,QAM1C,SAAS2E,EAAKyJ,EAAezJ,GAClC,MAAO,CAAEgF,UAAW,OAAQ+F,SAAU,CAACtB,GAAOzJ,KAAAA,GAKzC,SAASmK,EAAUV,EAAezJ,EAAYiF,GACnD,MAAO,CAAED,UAAW,OAAQ+F,SAAU,CAACtB,GAAOzJ,KAAAA,EAAMoU,OAAO,EAAMnP,KAAAA,GAI5D,SAAS2E,EAAWrF,EAAyBU,GAClD,MAAO,CAAED,UAAW,OAAQ+F,SAAU,GAAIxG,KAAAA,EAAMU,KAAAA,EAAM4F,KAAM,UAEvD,SAASrG,EAAiBD,GAC/B,MAAO,CAAES,UAAW,OAAQ+F,SAAU,GAAIxG,KAAAA,EAAMsG,KAAM,UAEjD,SAASe,EAAK/B,EAAiC5E,GACpD,MAAO,CAAED,UAAW,OAAQ+F,SAAU,GAAIxG,KAAM,GAAIsF,KAAAA,EAAM5E,KAAAA,EAAM4F,KAAM,UAKjE,SAASmB,EAAWnC,GACzB,MAAO,CAAE7E,UAAW,OAAQ+F,SAAU,GAAIxG,KAAM,GAAIsF,KAAAA,EAAMgB,KAAM,UAE3D,SAASuO,IAAyC,IAAD,uBAA1BrO,EAA0B,yBAA1BA,EAA0B,gBACtD,MAAO,CAAE/F,UAAW,OAAQ+F,SAAU+N,EAAQ/N,IAGzC,SAASsO,EAAa7F,EAAgBW,EAAWlP,GACtD,MAAO,CAAED,UAAW,YAAa+F,SAAU,CAACyI,GAAQW,KAAAA,EAAMlP,KAAAA,GAM5D,SAAS6T,EAAQ1U,GACf,OAAOA,EAAOhJ,KAAI,SAAAP,GAAK,MAAqB,kBAAVA,EAAqBA,EAAQ2L,EAAS3L,MAK1E,SAASge,EAAMhe,GACb,MAAyB,kBAAVA,EAAsB2L,EAAS3L,GAASA,EAkBlD,SAASye,EAAUvF,EAAeC,EAAeC,EAAkBC,EAAoBjP,GAC5F,MAAO,CAAED,UAAW,QAAS+F,SAAU,CAAC8N,EAAM9E,GAAK8E,EAAM7E,GAAK6E,EAAM5E,GAAQ4E,EAAM3E,IAAWjP,KAAAA,K,0FC7KhF,SAASsU,EAA6Ble,EAAame,GAChE,IAAQC,GAAaC,EAAAA,EAAAA,YAAWC,EAAAA,GAAxBF,SACR,GAA0B/hB,EAAAA,EAAAA,WAAS,kBAAM+hB,EAASG,OAAOC,YAAexe,EAAKme,MAA7E,eAAOM,EAAP,KAAcC,EAAd,MAEAC,EAAAA,EAAAA,YAAU,kBACR3e,EAAMoe,EAASG,OAAOK,OAAO5e,EAAK0e,QAAmBvhB,IACrD,CAAC6C,EAAK0e,EAAUN,KAClBO,EAAAA,EAAAA,YAAU,kBAAMD,EAASN,EAASG,OAAOC,YAAexe,EAAKme,MAAQ,CAACC,EAAUD,EAAMne,IACtF,IAAM6e,GAAcliB,EAAAA,EAAAA,cAClB,SAAA6C,GAAK,OAAI4e,EAASG,OAAOlT,IAAIrL,EAAKR,KAClC,CAAC4e,EAAUpe,IAGb,MAAO,QAACye,QAAD,IAACA,EAAAA,EAASN,IAAQU,K,gFCdZ,SAASC,IACtB,OAA6BziB,EAAAA,EAAAA,UAAS,IAAtC,eAAO0iB,EAAP,KAAmBC,EAAnB,KAEA,MAAO,CAACD,GADgBpiB,EAAAA,EAAAA,cAAY,kBAAMqiB,EAAO,MAAK,O,gFCFzC,SAASC,IACtB,IAAMpkB,GAAQqkB,EAAAA,EAAAA,KACRC,GAAKC,EAAAA,EAAAA,GAAcvkB,EAAMwkB,YAAYC,GAAG,OACxCC,GAAKH,EAAAA,EAAAA,GAAcvkB,EAAMwkB,YAAYC,GAAG,OACxCE,GAAKJ,EAAAA,EAAAA,GAAcvkB,EAAMwkB,YAAYC,GAAG,OAE9C,OADWF,EAAAA,EAAAA,GAAcvkB,EAAMwkB,YAAYC,GAAG,OAC/B,KACXE,EAAW,KACXD,EAAW,KACXJ,EAAW,KACR,O,gFCJM,SAASM,EAAcC,EAA2C/F,GAAoD,IAA/BgG,IAA8B,yDAClI,GAAsBtjB,EAAAA,EAAAA,eAAwBc,GAA9C,eAAOkW,EAAP,KAAYuM,EAAZ,KASA,OARAjB,EAAAA,EAAAA,YAAU,WAAO,IAAD,IACVkB,GAAU,EAEd,OADA,UAAW,QAAX,EAAAH,WAAA,eAAepb,MAAK,SAAA+O,GAAG,OAAIwM,GAAWD,EAAOvM,KAAMpJ,QAAQC,cAA3D,OAAqE0V,OAAOziB,GACrE,WACL0iB,GAAU,GACTF,GAAUC,OAAOziB,MAEnBwc,GACItG,I,sHCbIyM,EAAoB,CAAC,QAAS,SAAU,QAG9C,SAASC,EAAqB3B,EAA2B/Z,GAC9D,MAAO,CACL2b,IAAK,CACHC,SAAU,SAACC,GAAD,OAAQ9B,EAAS+B,MAAMja,IAAIga,GAAsB,EAAI,GAC/DE,WAAY,QAEd3iB,KAAM,CACJwiB,SAAU,SAACC,GAAD,OAAQG,EAAAA,EAAAA,EAAA,wBAAwBH,IAAMI,aAElDha,MAAO,CACL2Z,SAAU,SAACC,GACT,IAAMzU,EAAO2S,EAAS+B,MAAMja,IAAIga,GAChC,OAAKzU,EACEA,EAAKnF,MAAQmF,EAAKlF,UADP,GAGpB6Z,WAAY,UAEdra,OAAQ,CACNka,SAAU,SAACC,GAAD,oBAAQ7b,QAAR,IAAQA,GAAR,UAAQA,EAAkB6b,UAA1B,aAAQ,EAAuBna,QACzCqa,WAAY,UAMX,SAASG,EAAuBnC,EAA2B/Z,GAChE,MAAO,CACLwO,QAAS,SAACqN,EAAItQ,GAAL,eAAgBA,EAAOvI,SAAP,OAAgBhD,QAAhB,IAAgBA,GAAhB,UAAgBA,EAAkB6b,UAAlC,aAAgB,EAAuBla,aACtD,aAAPka,IAAsB9B,EAAS+B,MAAMja,IAAIga,IAAuBtQ,EAAO4Q,MAAK,SAAAC,GAAE,OAAIpc,EAAgBqc,SAASC,YAAYtZ,SAASoZ,OACzH,aAAPP,GAAqBtQ,EAAOvI,SAAP,UAAgB+W,EAAS+B,MAAMja,IAAIga,UAAnC,aAAgB,EAAwCla,aAChF6K,WAAY,SAACqP,EAAItQ,GAAL,aAAgBA,EAAOvI,SAAP,OAAgBhD,QAAhB,IAAgBA,GAAhB,UAAgBA,EAAkB6b,UAAlC,aAAgB,EAAuBpb,gBACnE8b,SAAU,SAACV,EAAItQ,GAAL,aACPA,GAAWA,KAAY,UAAAwO,EAAS+B,MAAMja,IAAIga,UAAnB,SAAwCU,SAAW,MAAQ,OACrFnjB,KAAM,SAACyiB,EAAItQ,GAAL,OAAiBA,GAAWyQ,EAAAA,EAAAA,EAAA,wBAAwBH,IAAMW,cAAcxZ,SAASuI,EAAOiR,mB,4FCnC3F,SAASC,EAAqCC,EAAgBrhB,EAAoBshB,GACvF,SAASC,EAAKnM,EAAMC,EAAMrV,EAAoBwhB,GAC5C,IAAMC,EAAKD,EAAOjB,SAASnL,GACrBsM,EAAKF,EAAOjB,SAASlL,GAM3B,OAAQrV,GAAa,EAAI,IAJP,kBAAPyhB,GAAiC,kBAAPC,EAC5BD,EAAGE,cAAcD,GAEfA,EAAiBD,GAG9B,OAAO,SAACrM,EAAMC,GACZ,IAAKiM,EAAQD,GAAS,OAAO,EAC7B,IAAMO,EAAeN,EAAQD,GACzBQ,EAAON,EAAKnM,EAAGC,EAAGrV,EAAW4hB,GAGjC,OAFKC,GAAQD,EAAalB,YAAcY,EAAQM,EAAalB,cAC3DmB,EAAON,EAAKnM,EAAGC,EAAGrV,EAAWshB,EAAQM,EAAalB,cAC7CmB,GAMJ,SAASC,EAAuCC,EAAkCC,GACvF,OAAO,SAACC,GAAD,OAAYvf,OAAOwK,QAAQ6U,GAAezM,OAAM,+BAAE4M,EAAF,KAAaC,EAAb,YAA4BH,EAAcE,IAAqBF,EAAcE,GAAkBD,EAAKE","sources":["Assets/Assets.ts","Components/Card/CardDark.tsx","Components/Card/CardLight.tsx","Components/CloseButton.tsx","Components/ConditionalWrapper.tsx","Components/DropdownMenu/DropdownButton.tsx","Components/Image/ImgIcon.tsx","Components/ModalWrapper.tsx","Components/SolidToggleButtonGroup.tsx","Components/SortByButton.tsx","Components/StarDisplay.tsx","Components/StatIcon.tsx","Data/Characters/CharacterSheet.tsx","Data/SheetUtil.tsx","Formula/api.tsx","Formula/index.ts","Formula/internal.ts","Formula/optimization.ts","Formula/uiData.tsx","Formula/utils.ts","ReactHooks/useDBState.tsx","ReactHooks/useForceUpdate.tsx","ReactHooks/useMediaQueryUp.tsx","ReactHooks/usePromise.tsx","Util/CharacterSort.ts","Util/SortByFilters.ts"],"sourcesContent":["import bow from './icon_bow.png'\r\nimport catalyst from './icon_catalyst.png'\r\nimport claymore from './icon_claymore.png'\r\nimport polearm from './icon_polearm.png'\r\nimport sword from './icon_sword.png'\r\n\r\nimport fragile from './Item_Fragile_Resin.png'\r\nimport condensed from './Item_Condensed_Resin.png'\r\n\r\n//EXP BOOKS\r\nimport advice from './Item_Wanderer\\'s_Advice.png'\r\nimport wit from './Item_Hero\\'s_Wit.png'\r\nimport experience from './Item_Adventurer\\'s_Experience.png'\r\n\r\nimport team1 from './icon_team_1.png'\r\nimport team2 from './icon_team_2.png'\r\nimport team3 from './icon_team_3.png'\r\nimport team4 from './icon_team_4.png'\r\n\r\nimport flower from './icon_slot_flower.png'\r\nimport plume from './icon_slot_plume.png'\r\nimport sands from './icon_slot_sands.png'\r\nimport goblet from './icon_slot_goblet.png'\r\nimport circlet from './icon_slot_circlet.png'\r\n\r\nconst Assets = {\r\n  weaponTypes: { bow, catalyst, claymore, polearm, sword },\r\n  slot: {\r\n    flower,\r\n    plume,\r\n    sands,\r\n    goblet,\r\n    circlet,\r\n  },\r\n  resin: {\r\n    fragile,\r\n    condensed\r\n  },\r\n  exp_books: {\r\n    advice,\r\n    wit,\r\n    experience,\r\n  },\r\n  team: {\r\n    team1,\r\n    team2,\r\n    team3,\r\n    team4,\r\n  },\r\n};\r\nexport default Assets;\r\n","import { Card, styled } from \"@mui/material\";\r\n\r\nconst CardDark = styled(Card)(({ theme }) => ({\r\n  backgroundColor: theme.palette.contentDark.main\r\n}));\r\n\r\nexport default CardDark","import { Card, styled } from \"@mui/material\";\r\n\r\nconst CardLight = styled(Card)(({ theme }) => ({\r\n  backgroundColor: theme.palette.contentLight.main\r\n}));\r\n\r\nexport default CardLight","import { Close } from \"@mui/icons-material\";\r\nimport { Button, ButtonProps } from \"@mui/material\";\r\nimport { useTranslation } from \"react-i18next\";\r\ntype CloseButtonProps = ButtonProps & {\r\n  large?: boolean\r\n}\r\nexport default function CloseButton({ large = false, ...props }: CloseButtonProps) {\r\n  const { t } = useTranslation(\"ui\")\r\n  if (large)\r\n    return <Button color=\"error\" startIcon={<Close />} {...props} >{t`close`}</Button>\r\n  return <Button color=\"error\" sx={{ p: 1, minWidth: 0 }} {...props} >\r\n    <Close />\r\n  </Button>\r\n}\r\n","import { ReactNode } from \"react\";\r\n\r\ntype Prop = {\r\n  condition: boolean,\r\n  wrapper: (children: ReactNode) => ReactNode\r\n  falseWrapper?: (children: ReactNode) => ReactNode\r\n  children: ReactNode\r\n}\r\n// Wrap children with element provided by wrapper func when condition is true.\r\nexport default function ConditionalWrapper({ condition, wrapper, falseWrapper, children }: Prop) {\r\n  return (condition ? wrapper(children) : (falseWrapper ? falseWrapper(children) : children)) as JSX.Element;\r\n}","import { KeyboardArrowDown } from \"@mui/icons-material\";\r\nimport { Button, ButtonProps, Menu, Skeleton } from \"@mui/material\";\r\nimport { Suspense, useCallback, useState } from \"react\";\r\n\r\nexport type DropdownButtonProps = Omit<ButtonProps, \"title\"> & {\r\n  title: React.ReactNode,\r\n  id?: string,\r\n  children: React.ReactNode\r\n}\r\nexport default function DropdownButton({ title, children, id = \"dropdownbtn\", ...props }: DropdownButtonProps) {\r\n  const [anchorEl, setAnchorEl] = useState<null | HTMLElement>(null);\r\n  const open = Boolean(anchorEl);\r\n  const handleClick = useCallback(\r\n    (event: React.MouseEvent<HTMLButtonElement>) => setAnchorEl(event.currentTarget),\r\n    [setAnchorEl],\r\n  )\r\n  const handleClose = useCallback(\r\n    () => setAnchorEl(null),\r\n    [setAnchorEl],\r\n  )\r\n\r\n  return <Suspense fallback={<Button endIcon={<KeyboardArrowDown />}{...props}><Skeleton width={50} /></Button>} >\r\n    <Button\r\n      {...props}\r\n      id={id}\r\n      aria-controls=\"basic-menu\"\r\n      aria-haspopup=\"true\"\r\n      aria-expanded={open ? 'true' : undefined}\r\n      onClick={handleClick}\r\n      endIcon={<KeyboardArrowDown />}\r\n    >\r\n      {title}\r\n    </Button>\r\n    <Menu\r\n      id=\"basic-menu\"\r\n      anchorEl={anchorEl}\r\n      open={open}\r\n      onClose={handleClose}\r\n      MenuListProps={{\r\n        'aria-labelledby': id,\r\n      }}\r\n      onClick={handleClose}\r\n    >\r\n      {/* set Skeleton to be really high so the taller dropdowns can still be placed properly... */}\r\n      <Suspense fallback={<Skeleton width=\"100%\" height=\"1000\" />}>\r\n        {children}\r\n      </Suspense>\r\n    </Menu>\r\n  </Suspense>\r\n}","import { styled } from \"@mui/material\"\r\ninterface ImgIconProps {\r\n  size?: number;\r\n}\r\nconst ImgIcon = styled(\"img\", {\r\n  name: 'ImgIcon',\r\n  slot: 'Root',\r\n})<ImgIconProps>(({ size = 1 }) => ({\r\n  display: \"inline-block\",\r\n  width: \"auto\",\r\n  height: `${size * 1.2}em`,\r\n  verticalAlign: \"text-bottom\"\r\n}))\r\n\r\nexport default ImgIcon","import { CardContent, Container, ContainerProps, Modal, ModalProps, Skeleton, styled } from \"@mui/material\"\r\nimport { Suspense } from \"react\"\r\nimport CardLight from \"./Card/CardLight\"\r\n\r\nconst ScrollModal = styled(Modal)(({ theme }) => ({\r\n  overflow: \"scroll\",\r\n  paddingTop: theme.spacing(2),\r\n  paddingBottom: theme.spacing(2),\r\n\r\n}))\r\nconst ModalContainer = styled(Container)(({ theme }) => ({\r\n  padding: 0,\r\n  minHeight: \"100%\",\r\n  display: \"flex\", flexDirection: \"column\", justifyContent: \"center\",\r\n  pointerEvents: \"none\",\r\n  \"& > *\": {\r\n    pointerEvents: \"auto\"\r\n  }\r\n}))\r\n\r\ntype ModalWrapperProps = ModalProps & {\r\n  containerProps?: ContainerProps\r\n}\r\nexport default function ModalWrapper({ children, containerProps, ...props }: ModalWrapperProps) {\r\n  return <ScrollModal {...props}>\r\n    <ModalContainer {...containerProps}>\r\n      <Suspense fallback={<CardLight><CardContent><Skeleton variant=\"rectangular\" width=\"100%\" height={300} /></CardContent></CardLight>}>\r\n        {children}\r\n      </Suspense>\r\n    </ModalContainer>\r\n  </ScrollModal>\r\n}","import { ButtonProps, styled, ToggleButtonGroup, ToggleButtonGroupProps } from \"@mui/material\";\r\n\r\nexport type SolidToggleButtonGroupProps = SolidToggleButtonGroupPropsPartial & ToggleButtonGroupProps\r\ntype SolidToggleButtonGroupPropsPartial = {\r\n  baseColor?: ButtonProps[\"color\"];\r\n  selectedColor?: ButtonProps[\"color\"];\r\n}\r\n\r\nconst SolidToggleButtonGroup = styled(ToggleButtonGroup, {\r\n  shouldForwardProp: (prop) => prop !== \"baseColor\" && prop !== \"selectedColor\"\r\n})<SolidToggleButtonGroupPropsPartial>(({ theme, baseColor = \"secondary\", selectedColor = \"success\" }) => ({\r\n  '& .MuiToggleButtonGroup-grouped': {\r\n    '&': {\r\n      backgroundColor: theme.palette[baseColor].main,\r\n      color: theme.palette[baseColor].contrastText,\r\n    },\r\n    '&:hover': {\r\n      backgroundColor: theme.palette[baseColor].dark,\r\n      transition: \"background-color 0.25s ease\",\r\n    },\r\n    '&.Mui-selected': {\r\n      backgroundColor: theme.palette[selectedColor].main,\r\n      color: theme.palette[selectedColor].contrastText,\r\n    },\r\n    '&.Mui-selected:hover': {\r\n      backgroundColor: theme.palette[selectedColor].dark,\r\n    },\r\n    '&.Mui-disabled': {\r\n      backgroundColor: theme.palette[baseColor].dark,\r\n    },\r\n    '&.Mui-selected.Mui-disabled': {\r\n      backgroundColor: theme.palette[selectedColor].dark,\r\n    },\r\n  },\r\n}));\r\n\r\nexport default SolidToggleButtonGroup\r\n","import { faSortAmountDownAlt, faSortAmountUp } from \"@fortawesome/free-solid-svg-icons\";\r\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\r\nimport { Button, ButtonGroup, ButtonGroupProps, MenuItem } from \"@mui/material\";\r\nimport { Box } from \"@mui/system\";\r\nimport { Trans, useTranslation } from \"react-i18next\";\r\nimport DropdownButton from \"./DropdownMenu/DropdownButton\";\r\n\r\ntype SortByButtonProps = ButtonGroupProps & {\r\n  sortKeys: string[]\r\n  value: string\r\n  onChange: (value: string) => void\r\n  ascending: boolean\r\n  onChangeAsc: (value: boolean) => void\r\n}\r\n// Assumes that all the sortKeys has corresponding translations in ui.json sortMap\r\nexport default function SortByButton({ sortKeys, value, onChange, ascending, onChangeAsc, ...props }: SortByButtonProps) {\r\n  const { t } = useTranslation(\"ui\")\r\n  return <Box display=\"flex\" alignItems=\"center\" gap={1}>\r\n    <Trans t={t} i18nKey={t(\"sortBy\") as any}>Sort by: </Trans>\r\n    <ButtonGroup {...props} >\r\n      <DropdownButton title={<Trans t={t} i18nKey={t(`sortMap.${value}`) as any}>{{ value: t(`sortMap.${value}`) }}</Trans>}>\r\n        {sortKeys.map(key =>\r\n          <MenuItem key={key} selected={value === key} disabled={value === key} onClick={() => onChange(key)}>{t(`sortMap.${key}`) as any}</MenuItem>)}\r\n      </DropdownButton>\r\n      <Button onClick={() => onChangeAsc(!ascending)} startIcon={<FontAwesomeIcon icon={ascending ? faSortAmountDownAlt : faSortAmountUp} className=\"fa-fw\" />}>\r\n        {ascending ? <Trans t={t} i18nKey=\"ascending\" >Ascending</Trans> : <Trans t={t} i18nKey=\"descending\" >Descending</Trans>}\r\n      </Button>\r\n    </ButtonGroup>\r\n  </Box>\r\n}\r\n","import { faStar } from '@fortawesome/free-solid-svg-icons'\r\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome'\r\nimport { Typography } from '@mui/material'\r\nimport { Rarity } from '../Types/consts'\r\n\r\nconst StarIcon = () => <FontAwesomeIcon icon={faStar} />\r\nconst Stars = ({ stars, colored = false }: { stars: Rarity, colored?: boolean }) =>\r\n  <Typography color={colored ? \"warning.main\" : undefined} component=\"span\">\r\n    {stars ? [...Array(stars).keys()].map((_, i) => <StarIcon key={i} />) : null}\r\n  </Typography>\r\n\r\nexport {\r\n  StarIcon,\r\n  Stars\r\n}\r\n","import { FontAwesomeIcon } from '@fortawesome/react-fontawesome'\r\nimport { objectKeyMap } from '../Util/Util'\r\nimport ColorText from './ColoredText'\r\nimport { faAnemo, faAtk, faCdReduction, faCritDmg, faCritRate, faCryo, faDef, faDendro, faElectro, faElementalMastery, faEnergyRecharge, faGeo, faHealingAdd, faHealingBonus, faHp, faHydro, faMaxStamina, faPhysicalDmgBonus, faPyro, faShieldStrength } from './faIcons'\r\n\r\nexport const uncoloredEleIcons = {\r\n  anemo: <FontAwesomeIcon icon={faAnemo as any} />,\r\n  geo: <FontAwesomeIcon icon={faGeo as any} />,\r\n  electro: <FontAwesomeIcon icon={faElectro as any} />,\r\n  hydro: <FontAwesomeIcon icon={faHydro as any} />,\r\n  pyro: <FontAwesomeIcon icon={faPyro as any} />,\r\n  cryo: <FontAwesomeIcon icon={faCryo as any} />,\r\n  dendro: <FontAwesomeIcon icon={faDendro as any} />,\r\n  physical: <FontAwesomeIcon icon={faPhysicalDmgBonus as any} />,\r\n} as const\r\nconst coloredEleIcon = objectKeyMap(Object.keys(uncoloredEleIcons), key => <ColorText color={key} sx={{ lineHeight: 1 }} >{uncoloredEleIcons[key]}</ColorText>)\r\n\r\nconst StatIcon = {\r\n  hp_: <FontAwesomeIcon icon={faHp as any} />,\r\n  hp: <FontAwesomeIcon icon={faHp as any} />,\r\n\r\n  atk_: <FontAwesomeIcon icon={faAtk as any} />,\r\n  atk: <FontAwesomeIcon icon={faAtk as any} />,\r\n\r\n  def_: <FontAwesomeIcon icon={faDef as any} />,\r\n  def: <FontAwesomeIcon icon={faDef as any} />,\r\n\r\n  eleMas: <FontAwesomeIcon icon={faElementalMastery as any} />,\r\n  critRate_: <FontAwesomeIcon icon={faCritRate as any} />,\r\n  critDMG_: <FontAwesomeIcon icon={faCritDmg as any} />,\r\n  enerRech_: <FontAwesomeIcon icon={faEnergyRecharge as any} />,\r\n  incHeal_: <FontAwesomeIcon icon={faHealingAdd as any} />,\r\n  heal_: <FontAwesomeIcon icon={faHealingBonus as any} />,\r\n\r\n  cdRed_: <FontAwesomeIcon icon={faCdReduction as any} />,\r\n\r\n  shield_: <FontAwesomeIcon icon={faShieldStrength as any} />,\r\n  stamina: <FontAwesomeIcon icon={faMaxStamina as any} />,\r\n\r\n  ...coloredEleIcon,\r\n  ...Object.fromEntries(Object.keys(coloredEleIcon).flatMap(ele => [\r\n    [`${ele}_dmg_`, coloredEleIcon[ele]],\r\n    [`${ele}_res_`, coloredEleIcon[ele]],\r\n    [`${ele}_critDMG_`, coloredEleIcon[ele]],\r\n    [`${ele}_dmgInc`, coloredEleIcon[ele]],\r\n    [`${ele}_enemyRes_`, coloredEleIcon[ele]]\r\n  ]))\r\n}\r\n\r\nexport default StatIcon\r\n","import Assets from \"../../Assets/Assets\";\r\nimport ImgIcon from \"../../Components/Image/ImgIcon\";\r\nimport SqBadge from \"../../Components/SqBadge\";\r\nimport { Translate } from \"../../Components/Translate\";\r\nimport { input } from \"../../Formula\";\r\nimport { Data, NumNode } from \"../../Formula/type\";\r\nimport { greaterEq } from \"../../Formula/utils\";\r\nimport { CharacterKey, ElementKey, Rarity, WeaponTypeKey } from \"../../Types/consts\";\r\nimport { DocumentConditional, DocumentConditionalBase, DocumentSection, IDocumentFields, IDocumentHeader } from \"../../Types/sheet\";\r\nimport { ascensionMaxLevel } from \"../LevelData\";\r\nimport { st, trans } from \"../SheetUtil\";\r\n\r\nconst characterSheets = import('.').then(imp => imp.default)\r\n\r\ninterface TalentSheetElement {\r\n  name: Displayable //talentName\r\n  img: string\r\n  sections: DocumentSection[]\r\n}\r\n\r\nexport type TalentSheetElementKey = \"auto\" | \"skill\" | \"burst\" | \"sprint\" | \"passive\" | \"passive1\" | \"passive2\" | \"passive3\" | \"constellation1\" | \"constellation2\" | \"constellation3\" | \"constellation4\" | \"constellation5\" | \"constellation6\"\r\nexport type TalentSheet = {\r\n  sheets: Dict<TalentSheetElementKey, TalentSheetElement>\r\n}\r\n\r\n\r\ninterface ICharacterSheetBase {\r\n  name: Displayable\r\n  cardImg: string\r\n  thumbImg: string\r\n  thumbImgSide: string\r\n  barImg?: string\r\n  bannerImg?: string\r\n  rarity: Rarity\r\n  weaponTypeKey: WeaponTypeKey\r\n  gender: string\r\n  constellationName: Displayable\r\n  title: Displayable\r\n}\r\ninterface ICharacterSheetTalent extends ICharacterSheetBase {\r\n  elementKey: ElementKey\r\n  talent: TalentSheet\r\n}\r\ninterface ICharacterSheetTalents extends ICharacterSheetBase {\r\n  talents: Dict<ElementKey, TalentSheet>\r\n}\r\nexport type ICharacterSheet = ICharacterSheetTalent | ICharacterSheetTalents\r\n\r\nexport default class CharacterSheet {\r\n  sheet: ICharacterSheet;\r\n  private data: Data | Partial<Record<ElementKey, Data>>;\r\n  constructor(charSheet: ICharacterSheet, data: Data | Partial<Record<ElementKey, Data>>) {\r\n    this.sheet = charSheet\r\n    this.data = data\r\n  }\r\n  static get = (charKey: CharacterKey | \"\"): Promise<CharacterSheet> | undefined => charKey ? characterSheets.then(c => c[charKey]) : undefined\r\n  static get getAll() { return characterSheets }\r\n  get name() { return this.sheet.name }\r\n  get icon() { return <ImgIcon src={this.thumbImgSide} sx={{ height: \"2em\", marginTop: \"-2em\", marginLeft: \"-0.5em\" }} /> }\r\n  get nameWIthIcon() { return <span>{this.icon} {this.name}</span> }\r\n  get cardImg() { return this.sheet.cardImg }\r\n  get thumbImg() { return this.sheet.thumbImg }\r\n  get thumbImgSide() { return this.sheet.thumbImgSide }\r\n  get bannerImg() { return this.sheet.bannerImg }\r\n  get rarity() { return this.sheet.rarity }\r\n  get elementKey() { return \"elementKey\" in this.sheet ? this.sheet.elementKey : undefined }\r\n  get elementKeys() { return \"talents\" in this.sheet ? Object.keys(this.sheet.talents) : [] }\r\n  get weaponTypeKey() { return this.sheet.weaponTypeKey }\r\n  get constellationName() { return this.sheet.constellationName }\r\n\r\n  isMelee = () => {\r\n    const weaponTypeKey = this.sheet.weaponTypeKey\r\n    return weaponTypeKey === \"sword\" || weaponTypeKey === \"polearm\" || weaponTypeKey === \"claymore\"\r\n  }\r\n  get isTraveler() {\r\n    return \"talents\" in this.sheet\r\n  }\r\n  getData = (ele: ElementKey = \"anemo\"): Data => {\r\n    if (\"charKey\" in this.data)\r\n      return this.data\r\n    return this.data[ele]!\r\n  }\r\n  getTalent = (eleKey: ElementKey = \"anemo\"): TalentSheet | undefined => {\r\n    if (\"talent\" in this.sheet) return this.sheet.talent\r\n    else return this.sheet.talents[eleKey]\r\n  }\r\n  getTalentOfKey = (talentKey: TalentSheetElementKey, eleKey: ElementKey = \"anemo\") => this.getTalent(eleKey)?.sheets[talentKey]\r\n\r\n  static getLevelString = (level: number, ascension: number): string =>\r\n    `${level}/${ascensionMaxLevel[ascension]}`\r\n}\r\n\r\nconst talentTemplate = (talentKey: TalentSheetElementKey, tr: (string) => Displayable, img: string, docSections?: DocumentSection[]): TalentSheetElement => ({\r\n  name: tr(`${talentKey}.name`),\r\n  img,\r\n  sections: [\r\n    ...(talentKey !== \"auto\" ? [{ text: tr(`${talentKey}.description`) }] : []),\r\n    ...(docSections || []),\r\n  ],\r\n})\r\n\r\nconst talentHeader = (talentKey: TalentSheetElementKey, tr: (string) => Displayable, img: string): IDocumentHeader => {\r\n  return {\r\n    title: tr(`${talentKey}.name`),\r\n    icon: <ImgIcon size={2} sx={{ m: -1 }} src={img} />,\r\n    action: <SqBadge color=\"success\">{st(`talents.${talentKey}`)}</SqBadge>,\r\n    description: tr(`${talentKey}.description`),\r\n  }\r\n}\r\n\r\nconst headerTemplate = (talentKey: TalentSheetElementKey, tr: (string) => Displayable, img: string, partialSection: DocumentSection): DocumentSection => ({\r\n  ...partialSection,\r\n  header: talentHeader(talentKey, tr, img),\r\n  canShow: canShowTemplate(talentKey, partialSection.canShow),\r\n})\r\n\r\nconst fieldsTemplate = (talentKey: TalentSheetElementKey, partialFields: IDocumentFields): IDocumentFields => ({\r\n  ...partialFields,\r\n  canShow: canShowTemplate(talentKey, partialFields.canShow),\r\n})\r\n\r\nconst conditionalTemplate = (talentKey: TalentSheetElementKey, partialCond: DocumentConditionalBase, tr: (string) => Displayable, img: string): DocumentConditional => ({\r\n  ...partialCond,\r\n  header: { ...talentHeader(talentKey, tr, img), ...partialCond.header },\r\n  canShow: canShowTemplate(talentKey, partialCond.canShow),\r\n})\r\n\r\nconst canShowTalentsNodes: Partial<Record<TalentSheetElementKey, NumNode>> = {\r\n  \"passive1\": greaterEq(input.asc, 1, 1),\r\n  \"passive2\": greaterEq(input.asc, 4, 1),\r\n  \"constellation1\": greaterEq(input.constellation, 1, 1),\r\n  \"constellation2\": greaterEq(input.constellation, 2, 1),\r\n  \"constellation3\": greaterEq(input.constellation, 3, 1),\r\n  \"constellation4\": greaterEq(input.constellation, 4, 1),\r\n  \"constellation5\": greaterEq(input.constellation, 5, 1),\r\n  \"constellation6\": greaterEq(input.constellation, 6, 1),\r\n}\r\nfunction canShowTemplate(talentKey: TalentSheetElementKey, canShow: NumNode | undefined): NumNode | undefined {\r\n  if (!canShowTalentsNodes[talentKey]) {\r\n    return canShow\r\n  }\r\n  let compareVal\r\n  let val\r\n  if ([\"passive1\", \"passive2\"].includes(talentKey)) {\r\n    compareVal = input.asc\r\n    val = +talentKey.slice(-1) === 1 ? 1 : 4\r\n  } else {\r\n    compareVal = input.constellation\r\n    val = +talentKey.slice(-1)\r\n  }\r\n  // Try to reuse the base canShow node when possible for caching performance\r\n  return canShow\r\n    ? greaterEq(compareVal, val, canShow ? canShow : 1)\r\n    : canShowTalentsNodes[talentKey]\r\n}\r\n\r\ninterface ICharacterTemplate {\r\n  talentTemplate: (talentKey: TalentSheetElementKey, docSections?: DocumentSection[]) => TalentSheetElement\r\n  headerTemplate: (talentKey: TalentSheetElementKey, partialSection: DocumentSection) => DocumentSection\r\n  fieldsTemplate: (talentKey: TalentSheetElementKey, partialFields: IDocumentFields) => IDocumentFields\r\n  conditionalTemplate: (talentKey: TalentSheetElementKey, partialCond: DocumentConditionalBase) => DocumentConditional\r\n}\r\nexport const charTemplates = (cKey: CharacterKey, wKey: WeaponTypeKey, assets: Partial<Record<TalentSheetElementKey, string>>, travelerEle?: ElementKey): ICharacterTemplate => {\r\n  const [tr] = cKey === \"Traveler\"\r\n    ? [(key: string) => <Translate ns=\"char_Traveler_gen\" key18={`${travelerEle}.${key}`} />]\r\n    : trans(\"char\", cKey)\r\n  assets.auto = Assets.weaponTypes[wKey]\r\n  return {\r\n    talentTemplate: (talentKey: TalentSheetElementKey, docSections?: DocumentSection[]) => talentTemplate(talentKey, tr, assets[talentKey] ?? \"\", docSections),\r\n    headerTemplate: (talentKey: TalentSheetElementKey, partialSection: DocumentSection) => headerTemplate(talentKey, tr, assets[talentKey] ?? \"\", partialSection),\r\n    fieldsTemplate: (talentKey: TalentSheetElementKey, partialFields: IDocumentFields) => fieldsTemplate(talentKey, partialFields),\r\n    conditionalTemplate: (talentKey: TalentSheetElementKey, partialCond: DocumentConditionalBase) => conditionalTemplate(talentKey, partialCond, tr, assets[talentKey] ?? \"\")\r\n  }\r\n}\r\n","import { Translate } from \"../Components/Translate\"\r\nimport { ReadNode } from \"../Formula/type\"\r\nimport { customStringRead } from \"../Formula/utils\"\r\nimport { ArtifactSetKey, CharacterKey, WeaponKey } from \"../Types/consts\"\r\n\r\nexport const st = (strKey: string, values?: object) => <Translate ns=\"sheet\" key18={strKey} values={values} />\r\nexport const sgt = (strKey: string) => <Translate ns=\"sheet_gen\" key18={strKey} />\r\n\r\nexport const condReadNode = (path: string[]) => customStringRead([\"conditional\", ...path])\r\nexport function cond(key: CharacterKey | WeaponKey | ArtifactSetKey, subKey: string): [path: string[], node: ReadNode<string>] {\r\n  const path = [key, subKey]\r\n  const node = condReadNode(path)\r\n  return [path, node]\r\n}\r\n\r\ntype Translated = [tr: ((i18key: string) => Displayable), tran: ((i18key: string, values?: object) => Displayable)]\r\nexport function trans(typeKey: \"char\", key: CharacterKey): Translated\r\nexport function trans(typeKey: \"weapon\", key: WeaponKey): Translated\r\nexport function trans(typeKey: \"artifact\", key: ArtifactSetKey): Translated\r\nexport function trans(typeKey: \"char\" | \"weapon\" | \"artifact\", key: CharacterKey | WeaponKey | ArtifactSetKey): Translated {\r\n  return [\r\n    (strKey: string) => <Translate ns={`${typeKey}_${key}_gen`} key18={strKey} />,\r\n    (strKey: string, values?: object) => <Translate ns={`${typeKey}_${key}`} key18={strKey} values={values} />\r\n  ]\r\n}\r\n","import Artifact from \"../Data/Artifacts/Artifact\";\r\nimport { ICachedArtifact, MainStatKey, SubstatKey } from \"../Types/artifact\";\r\nimport { ICachedCharacter } from \"../Types/character\";\r\nimport { allElementsWithPhy, ArtifactSetKey, CharacterKey } from \"../Types/consts\";\r\nimport { ICachedWeapon } from \"../Types/weapon\";\r\nimport { crawlObject, deepClone, layeredAssignment, objectKeyMap, objPathValue } from \"../Util/Util\";\r\nimport { input } from \"./index\";\r\nimport { Data, DisplaySub, Info, Input, NumNode, ReadNode, StrNode } from \"./type\";\r\nimport { NodeDisplay, UIData } from \"./uiData\";\r\nimport { constant, customRead, percent, resetData, setReadNodeKeys } from \"./utils\";\r\n\r\nconst asConst = true as const, pivot = true as const\r\n\r\nfunction inferInfoMut(data: Data, source?: Info[\"source\"]): Data {\r\n  crawlObject(data, [], (x: any) => x.operation, (x: NumNode, path: string[]) => {\r\n    if (path[0] === \"teamBuff\") {\r\n      path = path.slice(1)\r\n      if (!x.info) x.info = {}\r\n      x.info.isTeamBuff = true\r\n    }\r\n    const reference = objPathValue(input, path) as ReadNode<number> | undefined\r\n    if (reference)\r\n      x.info = { ...x.info, ...reference.info, prefix: undefined, source }\r\n    else if (path[0] !== \"tally\")\r\n      console.error(`Detect ${source} buff into non-existant key path ${path}`)\r\n  })\r\n\r\n  return data\r\n}\r\nfunction dataObjForArtifact(art: ICachedArtifact, mainStatAssumptionLevel: number = 0): Data {\r\n  const mainStatVal = Artifact.mainStatValue(art.mainStatKey, art.rarity, Math.max(Math.min(mainStatAssumptionLevel, art.rarity * 4), art.level))\r\n  const stats: [ArtifactSetKey | MainStatKey | SubstatKey, number][] = []\r\n  stats.push([art.mainStatKey, mainStatVal])\r\n  art.substats.forEach(({ key, accurateValue }) => key && stats.push([key, accurateValue]))\r\n  return {\r\n    art: {\r\n      ...Object.fromEntries(stats.map(([key, value]) =>\r\n        key.endsWith(\"_\") ? [key, percent(value / 100)] : [key, constant(value)])),\r\n      [art.slotKey]: {\r\n        id: constant(art.id), set: constant(art.setKey)\r\n      },\r\n    },\r\n    artSet: {\r\n      [art.setKey]: constant(1),\r\n    },\r\n  }\r\n}\r\nfunction dataObjForCharacter(char: ICachedCharacter): Data {\r\n  const result: Data = {\r\n    lvl: constant(char.level),\r\n    constellation: constant(char.constellation),\r\n    asc: constant(char.ascension),\r\n    infusion: {\r\n      team: char.infusionAura ? constant(char.infusionAura) : undefined,\r\n    },\r\n    premod: {\r\n      auto: constant(char.talent.auto),\r\n      skill: constant(char.talent.skill),\r\n      burst: constant(char.talent.burst),\r\n    },\r\n    enemy: {\r\n      ...objectKeyMap(allElementsWithPhy.map(ele => `${ele}_res_`), ele =>\r\n        percent((char.enemyOverride[`${ele.slice(0, -5)}_enemyRes_`] ?? 10) / 100)),\r\n      level: constant(char.enemyOverride.enemyLevel ?? char.level),\r\n    },\r\n    hit: {\r\n      hitMode: constant(char.hitMode),\r\n      reaction: constant(char.reactionMode),\r\n    },\r\n    customBonus: {},\r\n  }\r\n\r\n  for (const [key, value] of Object.entries(char.bonusStats))\r\n    result.customBonus![key] = key.endsWith('_') ? percent(value / 100) : constant(value)\r\n\r\n  if (char.enemyOverride.enemyDefRed_)\r\n    result.premod!.enemyDefRed_ = percent(char.enemyOverride.enemyDefRed_ / 100)\r\n  if (char.enemyOverride.enemyDefIgn_)\r\n    result.enemy!.defIgn = percent(char.enemyOverride.enemyDefIgn_ / 100)\r\n\r\n  crawlObject(char.conditional, [\"conditional\"], (x: any) => typeof x === \"string\", (x: string, keys: string[]) =>\r\n    layeredAssignment(result, keys, constant(x)))\r\n  return result\r\n}\r\nfunction dataObjForWeapon(weapon: ICachedWeapon): Data {\r\n  return {\r\n    weapon: {\r\n      id: constant(weapon.id),\r\n      lvl: constant(weapon.level),\r\n      asc: constant(weapon.ascension),\r\n      refinement: constant(weapon.refinement),\r\n      refineIndex: constant(weapon.refinement - 1)\r\n    },\r\n  }\r\n}\r\n/** These read nodes are very context-specific, and cannot be used anywhere else outside of `uiDataForTeam` */\r\nconst teamBuff = setReadNodeKeys(deepClone(input), [\"teamBuff\"]); // Use ONLY by dataObjForTeam\r\nfunction uiDataForTeam(teamData: Dict<CharacterKey, Data[]>, activeCharKey?: CharacterKey): Dict<CharacterKey, { target: UIData, buffs: Dict<CharacterKey, UIData> }> {\r\n  // May the goddess of wisdom bless any and all souls courageous\r\n  // enough to attempt for the understanding of this abomination.\r\n\r\n  const mergedData = Object.entries(teamData).map(([key, data]) => [key, { ...mergeData(data) }] as [CharacterKey, Data])\r\n  const result = Object.fromEntries(mergedData.map(([key]) =>\r\n    [key, { targetRef: {} as Data, buffs: [] as Data[], calcs: {} as Dict<CharacterKey, Data> }]))\r\n\r\n  const customReadNodes = {}\r\n  function getReadNode(path: readonly string[]): ReadNode<number> {\r\n    const base = (path[0] === \"teamBuff\")\r\n      ? objPathValue(teamBuff, path.slice(1))\r\n      : objPathValue(input, path)\r\n    if (base) return base\r\n    const custom = objPathValue(customReadNodes, path)\r\n    if (custom) return custom\r\n    const newNode = customRead(path)\r\n    if (path[0] === \"teamBuff\" && path[1] === \"tally\") newNode.accu = \"add\"\r\n    layeredAssignment(customReadNodes, path, newNode)\r\n    return newNode\r\n  }\r\n\r\n  Object.values(result).forEach(({ targetRef, buffs, calcs }) =>\r\n    mergedData.forEach(([sourceKey, source]) => {\r\n      const sourceBuff = source.teamBuff\r\n      // Create new copy of `calc` as we're mutating it later\r\n      const buff: Data = {}, calc: Data = deepClone({ teamBuff: sourceBuff })\r\n      buffs.push(buff)\r\n      calcs[sourceKey] = calc\r\n\r\n      // This construction creates a `Data` representing buff\r\n      // from `source` applying to `target`. It has 3 data:\r\n      // - `target` contains the reference for the final\r\n      //   data. It is not populated at this stage,\r\n      // - `calc` contains the calculation of the buffs,\r\n      // - `buff` contains read nodes that point to the\r\n      //   calculation in `calc`.\r\n\r\n      crawlObject(sourceBuff, [], (x: any) => x.operation, (x: NumNode | StrNode, path: string[]) => {\r\n        const info: Info = { ...objPathValue(input, path), source: sourceKey, prefix: undefined, asConst }\r\n        layeredAssignment(buff, path, resetData(getReadNode([\"teamBuff\", ...path]), calc, info))\r\n\r\n        crawlObject(x, [], (x: any) => x?.operation === \"read\", (x: ReadNode<number | string>) => {\r\n          if (x.path[0] === \"targetBuff\") return // Ignore teamBuff access\r\n\r\n          let readNode: ReadNode<number | string> | undefined, data: Data\r\n          if (x.path[0] === \"target\") { // Link the node to target data\r\n            readNode = getReadNode(x.path.slice(1))\r\n            data = targetRef\r\n          } else { // Link the node to source data\r\n            readNode = x\r\n            data = result[sourceKey].targetRef\r\n          }\r\n          layeredAssignment(calc, x.path, resetData(readNode, data))\r\n        })\r\n      })\r\n    })\r\n  )\r\n  mergedData.forEach(([targetKey, data]) => {\r\n    delete data.teamBuff\r\n    const { targetRef, buffs } = result[targetKey]\r\n    const buff = mergeData(buffs)\r\n    crawlObject(buff ?? {}, [], (x => x.operation), (x: NumNode, path: string[]) => {\r\n      // CAUTION\r\n      // This is safe only because `buff` is created using only `resetData`\r\n      // and `mergeData`. So every node here is created from either of the\r\n      // two functions, so the mutation wont't affect existing nodes.\r\n      x.info = { ...(objPathValue(teamBuff, path) as ReadNode<number> | undefined)?.info, prefix: \"teamBuff\", pivot }\r\n    })\r\n    Object.assign(targetRef, mergeData([data, buff, { teamBuff: buff, activeCharKey: constant(activeCharKey) }]))\r\n    targetRef[\"target\"] = targetRef\r\n  })\r\n  const origin = new UIData(undefined as any, undefined)\r\n  return Object.fromEntries(Object.entries(result).map(([key, value]) =>\r\n    [key, {\r\n      target: new UIData(value.targetRef, origin),\r\n      buffs: Object.fromEntries(Object.entries(value.calcs).map(([key, value]) =>\r\n        [key, new UIData(value, origin)]))\r\n    }]))\r\n}\r\nfunction mergeData(data: Data[]): Data {\r\n  function internal(data: any[], path: string[]): any {\r\n    if (data.length <= 1) return data[0]\r\n    if (data[0].operation) {\r\n      if (path[0] === \"teamBuff\") path = path.slice(1)\r\n      let { accu, type } = (objPathValue(input, path) as ReadNode<number> | ReadNode<string> | undefined) ?? {}\r\n      if (path[0] === \"tally\") accu = \"add\"\r\n      else if (accu === undefined) {\r\n        const errMsg = `Multiple entries when merging \\`unique\\` for key ${path}`\r\n        if (process.env.NODE_ENV === \"development\")\r\n          throw new Error(errMsg)\r\n        else\r\n          console.error(errMsg)\r\n\r\n        accu = type === \"number\" ? \"max\" : \"small\"\r\n      }\r\n      const result: NumNode | StrNode = { operation: accu, operands: data }\r\n      return result\r\n    } else {\r\n      return Object.fromEntries([...new Set(data.flatMap(x => Object.keys(x) as string[]))]\r\n        .map(key => [key, internal(data.map(x => x[key]).filter(x => x), [...path, key])]))\r\n    }\r\n  }\r\n  return data.length ? internal(data, []) : {}\r\n}\r\n\r\nfunction computeUIData(data: Data[]): UIData {\r\n  return new UIData(mergeData(data), undefined)\r\n}\r\ntype ComparedNodeDisplay<V = number> = NodeDisplay<V> & { diff: V }\r\nfunction compareTeamBuffUIData(uiData1: UIData, uiData2: UIData): Input<ComparedNodeDisplay, ComparedNodeDisplay<string>> {\r\n  return compareInternal(uiData1.getTeamBuff(), uiData2.getTeamBuff())\r\n}\r\nfunction compareDisplayUIData(uiData1: UIData, uiData2: UIData): { [key: string]: DisplaySub<ComparedNodeDisplay> } {\r\n  return compareInternal(uiData1.getDisplay(), uiData2.getDisplay())\r\n}\r\nfunction compareInternal(data1: any | undefined, data2: any | undefined): any {\r\n  if (data1?.operation || data2?.operation) {\r\n    const d1 = data1 as NodeDisplay | undefined\r\n    const d2 = data2 as NodeDisplay | undefined\r\n\r\n    if ((d1 && !d1.operation) || (d2 && !d2.operation))\r\n      throw new Error(\"Unmatched structure when comparing UIData\")\r\n\r\n    const result: ComparedNodeDisplay = {\r\n      info: {},\r\n      operation: true,\r\n      value: 0,\r\n      isEmpty: true,\r\n      unit: d2?.unit!,\r\n      formulas: [],\r\n      ...d1,\r\n      diff: (d2?.value ?? 0) - (d1?.value ?? 0)\r\n    }\r\n    if (typeof d1?.value === \"string\" || typeof d2?.value === \"string\") {\r\n      // In case `string` got involved, just use the other value\r\n      result.value = d1?.value ?? \"\" as any\r\n      result.diff = d2?.value ?? \"\" as any\r\n    }\r\n    return result\r\n  }\r\n\r\n  if (data1 || data2) {\r\n    const keys = new Set([...Object.keys(data1 ?? {}), ...Object.keys(data2 ?? {})])\r\n    return Object.fromEntries([...keys].map(key => [key, compareInternal(data1?.[key], data2?.[key])]))\r\n  }\r\n}\r\n\r\nexport type { NodeDisplay, UIData };\r\nexport {\r\n  dataObjForArtifact, dataObjForCharacter, dataObjForWeapon,\r\n  mergeData, computeUIData, inferInfoMut,\r\n  uiDataForTeam, compareTeamBuffUIData, compareDisplayUIData\r\n};\r\n","import { allEleEnemyResKeys } from \"../KeyMap\"\r\nimport { allArtifactSets, allElementsWithPhy, allRegions, allSlotKeys } from \"../Types/consts\"\r\nimport { crawlObject, deepClone, objectKeyMap, objectKeyValueMap } from \"../Util/Util\"\r\nimport { Data, Info, NumNode, ReadNode, StrNode } from \"./type\"\r\nimport { constant, equalStr, frac, infoMut, lookup, max, min, naught, one, percent, prod, read, res, setReadNodeKeys, stringRead, sum, todo } from \"./utils\"\r\n\r\nconst asConst = true as const, pivot = true as const\r\n\r\nconst allElements = allElementsWithPhy\r\nconst allTalents = [\"auto\", \"skill\", \"burst\"] as const\r\nconst allMoves = [\"normal\", \"charged\", \"plunging\", \"skill\", \"burst\", \"elemental\"] as const\r\nconst allArtModStats = [\"hp\", \"hp_\", \"atk\", \"atk_\", \"def\", \"def_\", \"eleMas\", \"enerRech_\", \"critRate_\", \"critDMG_\", \"electro_dmg_\", \"hydro_dmg_\", \"pyro_dmg_\", \"cryo_dmg_\", \"physical_dmg_\", \"anemo_dmg_\", \"geo_dmg_\", \"heal_\"] as const\r\nconst allTransformative = [\"overloaded\", \"shattered\", \"electrocharged\", \"superconduct\", \"swirl\"] as const\r\nconst allAmplifying = [\"vaporize\", \"melt\"] as const\r\nconst allMisc = [\r\n  \"stamina\", \"staminaDec_\", \"staminaSprintDec_\", \"staminaGlidingDec_\", \"staminaChargedDec_\",\r\n  \"incHeal_\", \"shield_\", \"cdRed_\", \"moveSPD_\", \"atkSPD_\", \"weakspotDMG_\", \"dmgRed_\", \"healInc\"\r\n] as const\r\n\r\nconst allModStats = [\r\n  ...allArtModStats,\r\n  ...([\"all\", \"burning\", ...allTransformative, ...allAmplifying, ...allMoves] as const).map(x => `${x}_dmg_` as const),\r\n]\r\nconst allNonModStats = [\r\n  ...allElements.flatMap(x => [\r\n    `${x}_dmgInc` as const,\r\n    `${x}_critDMG_` as const,\r\n    `${x}_res_` as const]),\r\n  ...allMoves.flatMap(x => [\r\n    `${x}_dmgInc` as const,\r\n    `${x}_critDMG_` as const,\r\n    `${x}_critRate_` as const]),\r\n  \"all_dmgInc\" as const,\r\n  ...allEleEnemyResKeys,\r\n  \"enemyDefRed_\" as const,\r\n  ...allMisc,\r\n]\r\n\r\nconst talent = objectKeyMap(allTalents, _ => read())\r\nconst allModStatNodes = objectKeyMap(allModStats, key => read(undefined, { key }))\r\nconst allNonModStatNodes = objectKeyMap(allNonModStats, key => read(undefined, { key }))\r\n\r\nfor (const ele of allElements) {\r\n  allNonModStatNodes[`${ele}_res_`].info!.variant = ele\r\n  allNonModStatNodes[`${ele}_enemyRes_`].info!.variant = ele\r\n  allNonModStatNodes[`${ele}_critDMG_`].info!.variant = ele\r\n  allNonModStatNodes[`${ele}_dmgInc`].info!.variant = ele\r\n  allModStatNodes[`${ele}_dmg_`].info!.variant = ele\r\n}\r\nfor (const reaction of [...allTransformative, ...allAmplifying]) {\r\n  allModStatNodes[`${reaction}_dmg_`].info!.variant = reaction\r\n}\r\n\r\nfunction withDefaultInfo<T>(info: Info, value: T): T {\r\n  value = deepClone(value)\r\n  crawlObject(value, [], (x: any) => x.operation, (x: NumNode | StrNode) => x.info = { ...info, ...x.info, })\r\n  return value\r\n}\r\nfunction markAccu<T>(accu: ReadNode<number>[\"accu\"], value: T): void {\r\n  crawlObject(value, [], (x: any) => x.operation, (x: NumNode | StrNode) => {\r\n    if (x.operation === \"read\" && x.type === \"number\") x.accu = accu\r\n  })\r\n}\r\n\r\n/** All read nodes */\r\nconst input = setReadNodeKeys(deepClone({\r\n  activeCharKey: stringRead(),\r\n  charKey: stringRead(), charEle: stringRead(), weaponType: stringRead(),\r\n  lvl: read(undefined, { key: \"level\", prefix: \"char\" }), constellation: read(), asc: read(), special: read(),\r\n\r\n  infusion: {\r\n    overridableSelf: stringRead(\"small\"),\r\n    nonOverridableSelf: stringRead(\"small\"),\r\n    team: stringRead(\"small\"),\r\n  },\r\n\r\n  base: objectKeyMap(['atk', 'hp', 'def'], key => read(\"add\", { key })),\r\n  customBonus: withDefaultInfo({ prefix: \"custom\", pivot }, {\r\n    ...allModStatNodes, ...allNonModStatNodes,\r\n  }),\r\n  bonus: { ...talent },\r\n  premod: { ...talent, ...allModStatNodes, ...allNonModStatNodes },\r\n  total: withDefaultInfo({ prefix: \"total\", pivot }, {\r\n    ...talent, ...objectKeyValueMap(allTalents, talent => [`${talent}Index`, read()]),\r\n    ...allModStatNodes, ...allNonModStatNodes,\r\n    /** Total Crit Rate capped to [0%, 100%] */\r\n    cappedCritRate: read(undefined, { key: \"critRate_\" }),\r\n  }),\r\n\r\n  art: withDefaultInfo({ prefix: \"art\", asConst }, {\r\n    ...objectKeyMap(allArtModStats, key => allModStatNodes[key]),\r\n    ...objectKeyMap(allSlotKeys, _ => ({ id: stringRead(), set: stringRead() })),\r\n  }),\r\n  artSet: objectKeyMap(allArtifactSets, set => read(\"add\", { key: set })),\r\n\r\n  weapon: withDefaultInfo({ prefix: \"weapon\", asConst }, {\r\n    id: stringRead(),\r\n    key: stringRead(), type: stringRead(),\r\n\r\n    lvl: read(), asc: read(), refinement: read(), refineIndex: read(),\r\n    main: read(), sub: read(), sub2: read(),\r\n  }),\r\n\r\n  enemy: {\r\n    def: read(\"add\", { key: \"enemyDef_multi\", pivot }),\r\n    ...objectKeyMap(allElements.map(ele => `${ele}_resMulti` as const), _ => read()),\r\n\r\n    level: read(undefined, { key: \"enemyLevel\" }),\r\n    ...objectKeyValueMap(allElements, ele => [`${ele}_res_`, read(undefined)]),\r\n    defRed: read(undefined),\r\n    defIgn: read(\"add\", { key: \"enemyDefIgn_\", pivot }),\r\n  },\r\n\r\n  hit: {\r\n    ele: stringRead(), reaction: stringRead(), move: stringRead(), hitMode: stringRead(),\r\n    base: read(\"add\", { key: \"base\" }),\r\n\r\n    dmgBonus: read(\"add\", { key: \"dmg_\", pivot }),\r\n    dmgInc: read(\"add\", { key: \"dmgInc\", pivot }),\r\n    dmg: read(),\r\n  },\r\n}))\r\n\r\nconst { base, bonus, customBonus, premod, total, art, hit, enemy } = input\r\n\r\n// Adjust `info` for printing\r\nmarkAccu('add', {\r\n  bonus, customBonus, premod, art,\r\n  total: objectKeyMap(allModStats, stat => total[stat]),\r\n})\r\nbonus.auto.info = { key: \"autoBoost\" }\r\nbonus.skill.info = { key: \"skillBoost\" }\r\nbonus.burst.info = { key: \"burstBoost\" }\r\nbase.atk.info = { key: \"atk\", prefix: \"base\", pivot }\r\ndelete total.critRate_.info!.pivot\r\ntotal.critRate_.info!.prefix = \"uncapped\"\r\n\r\n// Nodes that are not used anywhere else but `common` below\r\n\r\n/** Base Amplifying Bonus */\r\nconst baseAmpBonus = sum(one, prod(25 / 9, frac(total.eleMas, 1400)))\r\n/** Effective reaction, taking into account the hit's element */\r\nexport const effectiveReaction = lookup(hit.ele, {\r\n  pyro: lookup(hit.reaction, { pyro_vaporize: constant(\"vaporize\"), pyro_melt: constant(\"melt\") }, undefined),\r\n  hydro: equalStr(hit.reaction, \"hydro_vaporize\", \"vaporize\"),\r\n  cryo: equalStr(hit.reaction, \"cryo_melt\", \"melt\"),\r\n}, undefined)\r\n\r\nconst common: Data = {\r\n  premod: {\r\n    ...objectKeyMap(allTalents, talent => bonus[talent]),\r\n    ...objectKeyMap(allNonModStats, key => customBonus[key]),\r\n    ...objectKeyMap(allModStats, key => {\r\n      const operands: NumNode[] = []\r\n      switch (key) {\r\n        case \"atk\": case \"def\": case \"hp\":\r\n          operands.push(prod(base[key], sum(one, premod[`${key}_`])))\r\n          break\r\n        case \"critRate_\":\r\n          operands.push(percent(0.05, { key, prefix: \"default\" }),\r\n            lookup(hit.move, objectKeyMap(allMoves, move => premod[`${move}_critRate_`]), 0))\r\n          break\r\n        case \"critDMG_\":\r\n          operands.push(percent(0.5, { key, prefix: \"default\" }),\r\n            lookup(hit.ele, objectKeyMap(allElements, ele => premod[`${ele}_critDMG_`]), 0),\r\n            lookup(hit.move, objectKeyMap(allMoves, ele => premod[`${ele}_critDMG_`]), 0))\r\n          break\r\n        case \"enerRech_\":\r\n          operands.push(percent(1, { key, prefix: \"default\" }))\r\n          break\r\n      }\r\n      return sum(...[...operands, art[key], customBonus[key]].filter(x => x))\r\n    }),\r\n  },\r\n  total: {\r\n    ...objectKeyMap(allTalents, talent => premod[talent]),\r\n    ...objectKeyMap(allModStats, key => premod[key]),\r\n    ...objectKeyMap(allNonModStats, key => premod[key]),\r\n    ...objectKeyValueMap(allTalents, talent => [`${talent}Index`, sum(total[talent], -1)]),\r\n    stamina: sum(constant(100, { key: \"stamina\", prefix: \"default\" }), customBonus.stamina),\r\n\r\n    cappedCritRate: max(min(total.critRate_, one), naught),\r\n  },\r\n\r\n  hit: {\r\n    dmgBonus: sum(\r\n      total.all_dmg_,\r\n      lookup(hit.move, objectKeyMap(allMoves, move => total[`${move}_dmg_`]), naught),\r\n      lookup(hit.ele, objectKeyMap(allElements, ele => total[`${ele}_dmg_`]), naught)\r\n    ),\r\n    dmgInc: sum(\r\n      total.all_dmgInc,\r\n      lookup(hit.ele, objectKeyMap(allElements, element => total[`${element}_dmgInc`]), NaN),\r\n      lookup(hit.move, objectKeyMap(allMoves, move => total[`${move}_dmgInc`]), NaN)\r\n    ),\r\n    dmg: prod(\r\n      sum(hit.base, hit.dmgInc),\r\n      sum(one, hit.dmgBonus),\r\n      lookup(hit.hitMode, {\r\n        hit: one,\r\n        critHit: sum(one, total.critDMG_),\r\n        avgHit: sum(one, prod(total.cappedCritRate, total.critDMG_)),\r\n      }, NaN),\r\n      enemy.def,\r\n      lookup(hit.ele,\r\n        objectKeyMap(allElements, ele => enemy[`${ele}_resMulti` as const]), NaN),\r\n      lookup(effectiveReaction, {\r\n        melt: lookup(hit.ele, {\r\n          pyro: prod(2, sum(baseAmpBonus, total.melt_dmg_)),\r\n          cryo: prod(1.5, sum(baseAmpBonus, total.melt_dmg_)),\r\n        }, 1, { key: \"melt_dmg_\" }),\r\n        vaporize: lookup(hit.ele, {\r\n          hydro: prod(2, sum(baseAmpBonus, total.vaporize_dmg_)),\r\n          pyro: prod(1.5, sum(baseAmpBonus, total.vaporize_dmg_)),\r\n        }, 1, { key: \"vaporize_dmg_\" }),\r\n      }, 1),\r\n    ),\r\n  },\r\n\r\n  enemy: {\r\n    // TODO: shred cap of 90%\r\n    def: frac(sum(input.lvl, 100), prod(sum(enemy.level, 100), sum(one, prod(-1, enemy.defRed)), sum(one, prod(-1, enemy.defIgn)))),\r\n    defRed: total.enemyDefRed_,\r\n    ...objectKeyValueMap(allElements, ele =>\r\n      [`${ele}_resMulti`, res(infoMut(sum(enemy[`${ele}_res_`], total[`${ele}_enemyRes_`]), { key: `${ele}_res_`, variant: ele }))]),\r\n  },\r\n}\r\n\r\nconst target = setReadNodeKeys(deepClone(input), [\"target\"])\r\nconst tally = {\r\n  ...setReadNodeKeys(objectKeyMap([...allElements, ...allRegions], _ => read(\"add\")), [\"tally\"]),\r\n  ele: todo,\r\n}\r\ntally.ele = sum(...allElements.map(ele => min(tally[ele], 1)))\r\n\r\n/**\r\n * List of `input` nodes, rearranged to conform to the needs of the\r\n * UI code. This is a separate list so that the evolution of the UIs\r\n * does not rely on the structure of `input`. So the UI code can rearrange\r\n * nodes as it sees fit without requiring updates to data sheets, which\r\n * pertains ~90% of all `input`-related code, and so are very sensitive\r\n * to any changes to `input`. For zero overhead, use the nodes directly\r\n * from `input` instead of a copy.\r\n */\r\nconst uiInput = input\r\n\r\nexport {\r\n  input, uiInput, common, customBonus,\r\n\r\n  target, tally,\r\n}\r\n","import { AnyNode, NumNode, StrNode } from \"./type\"\r\nimport { constant } from \"./utils\"\r\n\r\nexport function forEachNodes(formulas: (NumNode | StrNode)[], topDown: (formula: (NumNode | StrNode)) => void, bottomUp: (formula: (NumNode | StrNode)) => void): void {\r\n  const visiting = new Set<(NumNode | StrNode)>(), visited = new Set<(NumNode | StrNode)>()\r\n\r\n  function traverse(formula: (NumNode | StrNode)) {\r\n    if (visited.has(formula)) return\r\n\r\n    if (visiting.has(formula)) {\r\n      console.error(\"Found cyclical dependency during formula traversal\")\r\n      return\r\n    }\r\n    visiting.add(formula)\r\n\r\n    topDown(formula)\r\n\r\n    formula.operands.forEach(traverse)\r\n\r\n    bottomUp(formula)\r\n\r\n    visiting.delete(formula)\r\n    visited.add(formula)\r\n  }\r\n\r\n  formulas.forEach(traverse)\r\n}\r\n\r\nexport function mapFormulas(formulas: NumNode[], topDownMap: (formula: (NumNode | StrNode)) => (NumNode | StrNode), bottomUpMap: (current: (NumNode | StrNode), orig: (NumNode | StrNode)) => (NumNode | StrNode)): NumNode[]\r\nexport function mapFormulas(formulas: (NumNode | StrNode)[], topDownMap: (formula: (NumNode | StrNode)) => (NumNode | StrNode), bottomUpMap: (current: (NumNode | StrNode), orig: (NumNode | StrNode)) => (NumNode | StrNode)): (NumNode | StrNode)[] {\r\n  const visiting = new Set<(NumNode | StrNode)>()\r\n  const topDownMapped = new Map<(NumNode | StrNode), (NumNode | StrNode)>()\r\n  const bottomUpMapped = new Map<(NumNode | StrNode), (NumNode | StrNode)>()\r\n\r\n  function check(formula: (NumNode | StrNode)): (NumNode | StrNode) {\r\n    let topDown = topDownMapped.get(formula)\r\n    if (topDown) return topDown\r\n    topDown = topDownMap(formula)\r\n\r\n    let bottomUp = bottomUpMapped.get(topDown)\r\n    if (bottomUp) return bottomUp\r\n\r\n    if (visiting.has(topDown)) {\r\n      console.error(\"Found cyclical dependency during formula mapping\")\r\n      return constant(NaN)\r\n    }\r\n    visiting.add(topDown)\r\n\r\n    bottomUp = bottomUpMap(traverse(topDown), formula)\r\n\r\n    visiting.delete(topDown)\r\n\r\n    topDownMapped.set(formula, bottomUp)\r\n    bottomUpMapped.set(topDown, bottomUp)\r\n    return bottomUp\r\n  }\r\n\r\n  function traverse(formula: (NumNode | StrNode)): (NumNode | StrNode) {\r\n    const operands = formula.operands.map(check)\r\n    return arrayEqual(operands, formula.operands) ? formula : { ...formula, operands } as any\r\n  }\r\n\r\n  const result = formulas.map(check)\r\n  return arrayEqual(result, formulas) ? formulas : result\r\n}\r\n\r\nexport function mapContextualFormulas(formulas: NumNode[], baseContextId: number, topDownMap: (formula: AnyNode, contextId: ContextID) => [AnyNode, ContextID], bottomUpMap: (formula: AnyNode, orig: AnyNode, contextId: ContextID, origContextId: ContextID) => AnyNode): NumNode[]\r\nexport function mapContextualFormulas(formulas: AnyNode[], baseContextId: number, topDownMap: (formula: AnyNode, contextId: ContextID) => [AnyNode, ContextID], bottomUpMap: (formula: AnyNode, orig: AnyNode, contextId: ContextID, origContextId: ContextID) => AnyNode): AnyNode[] {\r\n  const visiting = new Set<AnyNode>()\r\n  const topDownByContext = new Map<ContextID, Map<AnyNode, AnyNode>>()\r\n  const bottomUpByContext = new Map<ContextID, Map<AnyNode, AnyNode>>()\r\n\r\n  function check(formula: AnyNode, parentContextId: ContextID): AnyNode {\r\n    let topDownMapping = topDownByContext.get(parentContextId)\r\n    if (!topDownMapping) {\r\n      topDownMapping = new Map()\r\n      topDownByContext.set(parentContextId, topDownMapping)\r\n    }\r\n\r\n    let topDown = topDownMapping.get(formula)\r\n    if (topDown) return topDown\r\n    let topDownContextId: number\r\n    [topDown, topDownContextId] = topDownMap(formula, parentContextId)\r\n\r\n    if (visiting.has(topDown)) {\r\n      console.error(\"Found cyclical dependency during formula mapping\")\r\n      return constant(NaN)\r\n    }\r\n\r\n    let bottomUpMapping = bottomUpByContext.get(topDownContextId)\r\n    if (!bottomUpMapping) {\r\n      bottomUpMapping = new Map()\r\n      bottomUpByContext.set(topDownContextId, bottomUpMapping)\r\n    }\r\n\r\n    let bottomUp = bottomUpMapping.get(topDown)\r\n    if (bottomUp) return bottomUp\r\n\r\n    visiting.add(topDown)\r\n    bottomUp = bottomUpMap(traverse(topDown, topDownContextId), formula, topDownContextId, parentContextId)\r\n    visiting.delete(topDown)\r\n\r\n    bottomUpMapping.set(topDown, bottomUp)\r\n    topDownMapping.set(formula, bottomUp)\r\n    return bottomUp\r\n  }\r\n\r\n  function traverse(formula: AnyNode, contextId: ContextID): AnyNode {\r\n    const operands = formula.operands.map(f => check(f, contextId))\r\n    return arrayEqual(operands, formula.operands) ? formula : { ...formula, operands }\r\n  }\r\n\r\n  const result = formulas.map(f => check(f, baseContextId))\r\n  return arrayEqual(formulas, result) ? formulas : result\r\n}\r\n\r\ntype ContextID = number\r\n\r\nfunction arrayEqual<T>(a: readonly T[] | undefined, b: readonly T[] | undefined): boolean {\r\n  if (a === undefined) return b === undefined\r\n  if (b === undefined) return false\r\n\r\n  return a.length === b.length && a.every((value, i) => value === b[i])\r\n}\r\n","import { assertUnreachable, objectKeyMap, objPathValue } from \"../Util/Util\"\r\nimport { forEachNodes, mapFormulas } from \"./internal\"\r\nimport { constant } from \"./utils\"\r\nimport { CommutativeMonoidOperation, ComputeNode, ConstantNode, Data, NumNode, Operation, ReadNode, StrNode, StrPrioNode } from \"./type\"\r\n\r\nconst allCommutativeMonoidOperations: StrictDict<CommutativeMonoidOperation, (_: number[]) => number> = {\r\n  min: (x: number[]): number => Math.min(...x),\r\n  max: (x: number[]): number => Math.max(...x),\r\n  add: (x: number[]): number => x.reduce((a, b) => a + b, 0),\r\n  mul: (x: number[]): number => x.reduce((a, b) => a * b, 1),\r\n}\r\nexport const allOperations: StrictDict<Operation | \"threshold\", (_: number[]) => number> = {\r\n  ...allCommutativeMonoidOperations,\r\n  res: ([res]: number[]): number => {\r\n    if (res < 0) return 1 - res / 2\r\n    else if (res >= 0.75) return 1 / (res * 4 + 1)\r\n    return 1 - res\r\n  },\r\n  sum_frac: (x: number[]): number => x[0] / x.reduce((a, b) => a + b),\r\n  threshold: ([value, threshold, pass, fail]: number[]): number => value >= threshold ? pass : fail,\r\n}\r\n\r\nconst commutativeMonoidOperationSet = new Set(Object.keys(allCommutativeMonoidOperations) as (NumNode[\"operation\"])[])\r\n\r\nexport function optimize(formulas: NumNode[], topLevelData: Data, shouldFold = (_formula: ReadNode<number | string | undefined>) => false): NumNode[] {\r\n  formulas = constantFold(formulas, topLevelData, shouldFold)\r\n  formulas = flatten(formulas)\r\n  formulas = deduplicate(formulas)\r\n  return formulas\r\n}\r\nexport function precompute(formulas: NumNode[], binding: (readNode: ReadNode<number>) => string): [compute: () => Float64Array, mapping: Dict<string, number>, buffer: Float64Array] {\r\n  // TODO: Use min-cut to minimize the size of interim array\r\n  type Reference = string | number | { ins: Reference[] }\r\n\r\n  const uniqueReadStrings = new Set<string>()\r\n  const uniqueNumbers = new Set<number>()\r\n  const mapping = new Map<NumNode, Reference>()\r\n\r\n  forEachNodes(formulas, _ => { }, f => {\r\n    const { operation } = f\r\n    switch (operation) {\r\n      case \"read\":\r\n        if (f.type !== \"number\" || (f.accu && f.accu !== \"add\"))\r\n          throw new Error(`Unsupported ${operation} node in precompute`)\r\n        const name = binding(f)\r\n        uniqueReadStrings.add(name)\r\n        mapping.set(f, name)\r\n        break\r\n      case \"add\": case \"min\": case \"max\": case \"mul\":\r\n      case \"threshold\": case \"res\": case \"sum_frac\":\r\n        mapping.set(f, { ins: f.operands.map(op => mapping.get(op)!) })\r\n        break\r\n      case \"const\":\r\n        if (typeof f.value !== \"number\")\r\n          throw new Error(\"Found string constant while precomputing\")\r\n        const value = f.value\r\n        uniqueNumbers.add(value)\r\n        mapping.set(f as ConstantNode<number>, value)\r\n        break\r\n      case \"match\": case \"lookup\": case \"subscript\":\r\n      case \"prio\": case \"small\":\r\n      case \"data\": throw new Error(`Unsupported ${operation} node in precompute`)\r\n      default: assertUnreachable(operation)\r\n    }\r\n  })\r\n\r\n  /**\r\n   * [ Outputs , Input , Constants, Deduplicated Compute ]\r\n   *\r\n   * Note that only Compute nodes are deduplicated. Outputs are arranged\r\n   * in the same order as formulas even when they are duplicated. Inputs\r\n   * are arranged in the same order as the read strings, even when they\r\n   * overlap with outputs. If an output is a constant or a compute node,\r\n   * only put the data in the output region.\r\n   */\r\n  const locations = new Map<NumNode | number | string, number>()\r\n\r\n  const readStrings = [...uniqueReadStrings], readOffset = formulas.length\r\n  const constValues = [...uniqueNumbers]\r\n  const computations: { out: number, ins: number[], op: (_: number[]) => number, buff: number[] }[] = []\r\n\r\n  formulas.forEach((f, i) => {\r\n    locations.set(f, i)\r\n    if (f.operation === \"const\") locations.set(f.value, i)\r\n  })\r\n  // After this line, if some outputs are also read node, `locations`\r\n  // will point to the one in the read node portion instead.\r\n  readStrings.forEach((str, i) => locations.set(str, i + formulas.length))\r\n  let offset = formulas.length + readStrings.length\r\n  constValues.forEach(value => locations.has(value) || locations.set(value, offset++))\r\n\r\n  // `locations` is stable from this point on. We now only append new values.\r\n  // There is no change to existing values.\r\n  //\r\n  // DO NOT read from `location` prior to this line.\r\n  mapping.forEach((ref, node) => {\r\n    if (typeof ref !== \"object\") {\r\n      locations.set(node, locations.get(ref)!)\r\n      return\r\n    }\r\n    if (!locations.has(node)) locations.set(node, offset++)\r\n    computations.push({\r\n      out: locations.get(node)!,\r\n      ins: node.operands.map(op => locations.get(op)!),\r\n      op: allOperations[node.operation],\r\n      buff: Array(node.operands.length).fill(0),\r\n    })\r\n  })\r\n\r\n  const buffer = new Float64Array(offset).fill(0)\r\n  uniqueNumbers.forEach(number => buffer[locations.get(number)!] = number)\r\n\r\n  // Copy target for when some outputs are duplicated\r\n  const copyList = formulas.map((node, i) => {\r\n    const src = locations.get(node)!\r\n    return src !== i ? [src, i] : undefined!\r\n  }).filter(x => x)\r\n  const copyFormula = copyList.length ? () => {\r\n    copyList.forEach(([src, dst]) => buffer[dst] = buffer[src])\r\n  } : undefined\r\n\r\n  return [() => {\r\n    computations.forEach(({ out, ins, op, buff }) => {\r\n      ins.forEach((i, j) => buff[j] = buffer[i])\r\n      buffer[out] = op(buff)\r\n    })\r\n    copyFormula?.()\r\n    return buffer\r\n  }, objectKeyMap(readStrings, (_, i) => readOffset + i), buffer]\r\n}\r\n\r\nfunction flatten(formulas: NumNode[]): NumNode[] {\r\n  return mapFormulas(formulas, f => f, _formula => {\r\n    let result = _formula\r\n    if (commutativeMonoidOperationSet.has(_formula.operation as any)) {\r\n      const formula = _formula as ComputeNode\r\n      const { operation } = formula\r\n\r\n      let flattened = false\r\n      const operands = formula.operands.flatMap(dep =>\r\n        (dep.operation === operation) ? (flattened = true, dep.operands) : [dep])\r\n      result = flattened ? { ...formula, operands } : formula\r\n    }\r\n\r\n    return result\r\n  })\r\n}\r\nfunction deduplicate(formulas: NumNode[]): NumNode[] {\r\n  function elementCounts<T>(array: readonly T[]): Map<T, number> {\r\n    const result = new Map<T, number>()\r\n    for (const value of array) result.set(value, (result.get(value) ?? 0) + 1)\r\n    return result\r\n  }\r\n  function arrayFromCounts<T>(counts: Map<T, number>): T[] {\r\n    return [...counts].flatMap(([dep, count]) => Array(count).fill(dep))\r\n  }\r\n\r\n  const wrap = {\r\n    common: {\r\n      counts: new Map<NumNode, number>(),\r\n      formulas: new Set<NumNode>(),\r\n      operation: \"add\" as Operation\r\n    }\r\n  }\r\n\r\n  while (true) {\r\n    let next: typeof wrap.common | undefined\r\n\r\n    const factored: ComputeNode = { operation: wrap.common.operation, operands: arrayFromCounts(wrap.common.counts) }\r\n\r\n    let candidatesByOperation = new Map<Operation, [ComputeNode, Map<NumNode, number>][]>()\r\n    for (const operation of Object.keys(allCommutativeMonoidOperations))\r\n      candidatesByOperation.set(operation, [])\r\n\r\n    formulas = mapFormulas(formulas, _formula => {\r\n      if (wrap.common.formulas.has(_formula as NumNode)) {\r\n        const formula = _formula as ComputeNode\r\n        const remainingCounts = new Map(wrap.common.counts)\r\n        const operands = formula.operands.filter(dep => {\r\n          const count = remainingCounts.get(dep)\r\n          if (count) {\r\n            remainingCounts.set(dep, count - 1)\r\n            return false\r\n          }\r\n          return true\r\n        })\r\n\r\n        if (!operands.length)\r\n          return factored\r\n        operands.push(factored)\r\n        return { ...formula, operands }\r\n      }\r\n      return _formula\r\n    }, _formula => {\r\n      if (!commutativeMonoidOperationSet.has(_formula.operation as any)) return _formula\r\n      const formula = _formula as ComputeNode\r\n\r\n      if (next) {\r\n        if (next.operation === formula.operation) {\r\n          const currentCounts = elementCounts(formula.operands), commonCounts = new Map<NumNode, number>()\r\n          const nextCounts = next.counts\r\n          let total = 0\r\n\r\n          for (const [dependency, currentCount] of currentCounts.entries()) {\r\n            const commonCount = Math.min(currentCount, nextCounts.get(dependency) ?? 0)\r\n            if (commonCount) {\r\n              commonCounts.set(dependency, commonCount)\r\n              total += commonCount\r\n            } else commonCounts.delete(dependency)\r\n          }\r\n          if (total > 1) {\r\n            next.counts = commonCounts\r\n            next.formulas.add(formula)\r\n          }\r\n        }\r\n      } else {\r\n        const candidates = candidatesByOperation.get(formula.operation)!\r\n        const counts = elementCounts(formula.operands)\r\n\r\n        for (const [candidate, candidateCounts] of candidates) {\r\n          let total = 0\r\n\r\n          const commonCounts = new Map<NumNode, number>()\r\n          for (const [dependency, candidateCount] of candidateCounts.entries()) {\r\n            const count = Math.min(candidateCount, counts.get(dependency) ?? 0)\r\n            if (count) {\r\n              commonCounts.set(dependency, count)\r\n              total += count\r\n            }\r\n          }\r\n          if (total > 1) {\r\n            next = {\r\n              counts: commonCounts,\r\n              formulas: new Set([formula, candidate]),\r\n              operation: formula.operation\r\n            }\r\n            candidatesByOperation.clear()\r\n            break\r\n          }\r\n        }\r\n        if (!next) candidates.push([formula, counts])\r\n      }\r\n\r\n      return formula\r\n    })\r\n\r\n    if (next) wrap.common = next\r\n    else break\r\n  }\r\n\r\n  return formulas\r\n}\r\n\r\n/**\r\n * Replace nodes with known values with appropriate constants,\r\n * avoiding removal of any nodes that pass `isFixed` predicate\r\n */\r\nexport function constantFold(formulas: NumNode[], topLevelData: Data, shouldFold = (_formula: ReadNode<number | string | undefined>) => false): NumNode[] {\r\n  type Context = { data: Data[], processed: Map<NumNode | StrNode, NumNode | StrNode> }\r\n  const origin: Context = { data: [], processed: new Map() }\r\n  const nextContextMap = new Map([[origin, new Map<Data, Context>()]])\r\n\r\n  function fold(formula: StrNode, context: Context): StrNode\r\n  function fold(formula: NumNode, context: Context): NumNode\r\n  function fold(formula: NumNode | StrNode, context: Context): NumNode | StrNode\r\n  function fold(formula: NumNode | StrNode, context: Context): NumNode | StrNode {\r\n    const old = context.processed.get(formula)\r\n    if (old) return old\r\n\r\n    const { operation } = formula\r\n    let result: NumNode | StrNode\r\n    switch (operation) {\r\n      case \"const\": return formula\r\n      case \"add\": case \"mul\": case \"max\": case \"min\":\r\n        const f = allOperations[operation]\r\n        const numericOperands: number[] = []\r\n        const formulaOperands: NumNode[] = formula.operands.filter(formula => {\r\n          const folded = fold(formula, context)\r\n          return (folded.operation === \"const\")\r\n            ? (numericOperands.push(folded.value), false)\r\n            : true\r\n        }).map(x => fold(x, context))\r\n        const numericValue = f(numericOperands)\r\n\r\n        // Fold degenerate cases. This may incorrectly compute NaN\r\n        // results, which shouldn't appear under expected usage.\r\n        // - zero\r\n        //   - 0 * ... = 0\r\n        // - infinity\r\n        //   - max(infinity, ...) = infinity\r\n        //   - infinity + ... = infinity\r\n        // - (-infinity)\r\n        //   - min(-infinity, ...) - infinity\r\n        //   - (-infinity) + ... = -infinity\r\n        // - NaN\r\n        //   - operation(NaN, ...) = NaN\r\n        if (!isFinite(numericValue)) {\r\n          if ((operation !== \"mul\") &&\r\n            (operation !== \"max\" || numericValue > 0) &&\r\n            (operation !== \"min\" || numericValue < 0)) {\r\n            result = constant(numericValue)\r\n            break\r\n          }\r\n        } else if (operation === \"mul\" && numericValue === 0) {\r\n          result = constant(numericValue)\r\n          break\r\n        }\r\n\r\n        if (numericValue !== f([])) // Skip vacuous values\r\n          formulaOperands.push(constant(numericValue))\r\n        if (formulaOperands.length <= 1) result = formulaOperands[0] ?? constant(f([]))\r\n        else result = { operation, operands: formulaOperands }\r\n        break\r\n      case \"res\": case \"sum_frac\": {\r\n        const operands = formula.operands.map(x => fold(x, context))\r\n        const f = allOperations[operation]\r\n        if (operands.every(x => x.operation === \"const\"))\r\n          result = constant(f(operands.map(x => (x as ConstantNode<number>).value)))\r\n        else result = { ...formula, operands }\r\n        break\r\n      }\r\n      case \"lookup\": {\r\n        const index = fold(formula.operands[0], context)\r\n        if (index.operation === \"const\") {\r\n          const selected = formula.table[index.value!] ?? formula.operands[1]\r\n          if (selected) {\r\n            result = fold(selected, context)\r\n            break\r\n          }\r\n        }\r\n        throw new Error(`Unsupported ${operation} node while folding`)\r\n      }\r\n      case \"prio\": {\r\n        const first = formula.operands.find(op => {\r\n          const folded = fold(op, context)\r\n          if (folded.operation !== \"const\")\r\n            throw new Error(`Unsupported ${operation} node while folding`)\r\n          return folded.value !== undefined\r\n        })\r\n        result = first ? fold(first, context) : constant(undefined)\r\n        break\r\n      }\r\n      case \"small\": {\r\n        let smallest = undefined as ConstantNode<string | undefined> | undefined\r\n        for (const operand of formula.operands) {\r\n          const folded = fold(operand, context)\r\n          if (folded.operation !== \"const\")\r\n            throw new Error(`Unsupported ${operation} node while folding`)\r\n          if (smallest?.value === undefined || (folded.value !== undefined && folded.value < smallest.value))\r\n            smallest = folded\r\n        }\r\n        result = smallest ?? constant(undefined)\r\n        break\r\n      }\r\n      case \"match\": {\r\n        const [v1, v2, match, unmatch] = formula.operands.map((x: NumNode | StrNode) => fold(x, context))\r\n        if (v1.operation !== \"const\" || v2.operation !== \"const\")\r\n          throw new Error(`Unsupported ${operation} node while folding`)\r\n        result = (v1.value === v2.value) ? match : unmatch\r\n        break\r\n      }\r\n      case \"threshold\": {\r\n        const [value, threshold, pass, fail] = formula.operands.map(x => fold(x, context))\r\n        if (value.operation === \"const\" && threshold.operation === \"const\")\r\n          result = value.value >= threshold.value ? pass : fail\r\n        else\r\n          result = { ...formula, operands: [value, threshold, pass, fail] }\r\n        break\r\n      }\r\n      case \"subscript\": {\r\n        const [index] = formula.operands.map(x => fold(x, context))\r\n        result = (index.operation === \"const\")\r\n          ? constant(formula.list[index.value])\r\n          : { ...formula, operands: [index] }\r\n        break\r\n      }\r\n      case \"read\": {\r\n        const operands = context.data\r\n          .map(x => objPathValue(x, formula.path) as (NumNode | StrNode))\r\n          .filter(x => x)\r\n\r\n        if (operands.length === 0) {\r\n          if (shouldFold(formula)) {\r\n            const { accu } = formula\r\n            if (accu === undefined || accu === \"small\")\r\n              result = formula.type === \"string\" ? constant(undefined) : constant(NaN)\r\n            else result = constant(allOperations[accu]([]))\r\n          } else result = formula\r\n        } else if (formula.accu === undefined || operands.length === 1)\r\n          result = fold(operands[operands.length - 1], context)\r\n        else\r\n          result = fold({ operation: formula.accu, operands } as ComputeNode | StrPrioNode, context)\r\n        break\r\n      }\r\n      case \"data\":\r\n        if (formula.reset) context = origin\r\n        const map = nextContextMap.get(context)!\r\n        let nextContext = map.get(formula.data)\r\n        if (!nextContext) {\r\n          nextContext = { data: [...context.data, formula.data], processed: new Map() }\r\n          nextContextMap.set(nextContext, new Map())\r\n          map.set(formula.data, nextContext)\r\n        }\r\n        result = fold(formula.operands[0], nextContext)\r\n        break\r\n      default: assertUnreachable(operation)\r\n    }\r\n\r\n    context.processed.set(formula, result)\r\n    return result\r\n  }\r\n\r\n  const context = { data: [topLevelData], processed: new Map() }\r\n  nextContextMap.set(context, new Map())\r\n  nextContextMap.get(origin)!.set(topLevelData, context)\r\n  return formulas.map(x => fold(x, context))\r\n}\r\n\r\nexport const testing = {\r\n  constantFold, flatten, deduplicate\r\n}\r\n","import { uiInput } from \".\"\r\nimport ColorText from \"../Components/ColoredText\"\r\nimport KeyMap, { Unit, valueString } from \"../KeyMap\"\r\nimport { assertUnreachable, crawlObject, layeredAssignment, objPathValue } from \"../Util/Util\"\r\nimport { allOperations } from \"./optimization\"\r\nimport { ComputeNode, Data, DataNode, DisplaySub, Info, LookupNode, MatchNode, NumNode, ReadNode, StrNode, SubscriptNode, ThresholdNode, UIInput, Variant } from \"./type\"\r\n\r\nconst shouldWrap = true\r\nexport interface NodeDisplay<V = number> {\r\n  /** Leave this here to make sure one can use `crawlObject` on hierarchy of `NodeDisplay` */\r\n  operation: true\r\n  info: Info\r\n  value: V\r\n  /** Whether the node fails the conditional test (`threshold_add`, `match`, etc.) or consists solely of empty nodes */\r\n  isEmpty: boolean\r\n  unit: Unit\r\n  formula?: Displayable\r\n  formulas: Displayable[]\r\n}\r\n\r\nexport class UIData {\r\n  origin: UIData\r\n  children = new Map<Data, UIData>()\r\n\r\n  data: Data[]\r\n  nodes = new Map<NumNode | StrNode, ContextNodeDisplay<number | string | undefined>>()\r\n  processed = new Map<NumNode | StrNode, NodeDisplay<number | string | undefined>>()\r\n\r\n  display: any = undefined\r\n  teamBuff: any = undefined\r\n\r\n  constructor(data: Data, parent: UIData | undefined) {\r\n    if (data === undefined) {\r\n      // Secret *origin* initializer\r\n      this.data = []\r\n      this.origin = this\r\n    } else {\r\n      if (!parent)\r\n        parent = new UIData(undefined as any, undefined)\r\n\r\n      this.data = [data, ...parent.data]\r\n      this.origin = parent.origin\r\n    }\r\n  }\r\n\r\n  getDisplay(): {\r\n    [key: string]: DisplaySub<NodeDisplay>\r\n  } {\r\n    if (!this.display) this.display = this.getAll([\"display\"])\r\n    return this.display\r\n  }\r\n  getTeamBuff(): UIInput<NodeDisplay, NodeDisplay<string>> {\r\n    if (!this.teamBuff) {\r\n      const calculated = this.getAll([\"teamBuff\"]), result = {} as any\r\n      // Convert `input` to `uiInput`\r\n      crawlObject(uiInput, [], (x: any) => x.operation, (x: ReadNode<number> | ReadNode<string>, path: string[]) => {\r\n        const node = objPathValue(calculated, x.path) as NumNode | undefined\r\n        if (node) layeredAssignment(result, path, node)\r\n      })\r\n      this.teamBuff = result\r\n    }\r\n    return this.teamBuff\r\n  }\r\n  getAll(prefix: string[]): any {\r\n    const result = {}\r\n    for (const data of this.data) {\r\n      crawlObject(objPathValue(data, prefix) ?? {}, [], (x: any) => x.operation,\r\n        (x: NumNode, key: string[]) => layeredAssignment(result, key, this.get(x)))\r\n    }\r\n    return result\r\n  }\r\n  get(node: NumNode): NodeDisplay\r\n  get(node: StrNode): NodeDisplay<string | undefined>\r\n  get(node: NumNode | StrNode): NodeDisplay<number | string | undefined>\r\n  get(node: NumNode | StrNode): NodeDisplay<number | string | undefined> {\r\n    if (node === undefined) {\r\n      console.trace(\"Please report this bug with this trace\")\r\n      return { info: {}, operation: true, value: undefined, isEmpty: true, unit: \"\", formulas: [] }\r\n    }\r\n    const old = this.processed.get(node)\r\n    if (old) return old\r\n\r\n    const result = computeNodeDisplay(this.computeNode(node))\r\n    this.processed.set(node, result)\r\n    return result\r\n  }\r\n  private computeNode(node: NumNode): ContextNodeDisplay\r\n  private computeNode(node: StrNode): ContextNodeDisplay<string | undefined>\r\n  private computeNode(node: NumNode | StrNode): ContextNodeDisplay<number | string | undefined>\r\n  private computeNode(node: NumNode | StrNode): ContextNodeDisplay<number | string | undefined> {\r\n    const old = this.nodes.get(node)\r\n    if (old) return old\r\n\r\n    const { operation, info } = node\r\n    let result: ContextNodeDisplay<number | string | undefined>\r\n    switch (operation) {\r\n      case \"add\": case \"mul\": case \"min\": case \"max\":\r\n      case \"res\": case \"sum_frac\":\r\n        result = this._compute(node); break\r\n      case \"threshold\": result = this._threshold(node); break\r\n      case \"const\": result = this._constant(node.value); break\r\n      case \"subscript\": result = this._subscript(node); break\r\n      case \"read\": result = this._read(node); break\r\n      case \"data\": result = this._data(node); break\r\n      case \"match\": result = this._match(node); break\r\n      case \"lookup\": result = this._lookup(node); break\r\n      case \"prio\": result = this._prio(node.operands); break\r\n      case \"small\": result = this._small(node.operands); break\r\n      default: assertUnreachable(operation)\r\n    }\r\n\r\n    if (info) {\r\n      const { asConst } = info\r\n      result = { ...result }\r\n      result.info = mergeInfo(result.info, info)\r\n\r\n      // Pivot all keyed nodes for debugging\r\n      // if (info.key) result.info.pivot = true\r\n\r\n      if (asConst) {\r\n        delete result.formula\r\n        delete result.assignment\r\n        result.dependencies = new Set()\r\n      }\r\n      if (result.info.pivot || !result.formula)\r\n        result.mayNeedWrapping = false\r\n    }\r\n    createDisplay(result)\r\n\r\n    this.nodes.set(node, result)\r\n    return result\r\n  }\r\n\r\n  private prereadAll(path: readonly string[]): (NumNode | StrNode)[] {\r\n    return this.data.map(x => objPathValue(x, path) as NumNode | StrNode).filter(x => x)\r\n  }\r\n  private readFirst(path: readonly string[]): ContextNodeDisplay<number | string | undefined> | undefined {\r\n    const data = this.data.map(x => objPathValue(x, path) as NumNode | StrNode).find(x => x)\r\n    return data && this.computeNode(data)\r\n  }\r\n\r\n  private _prio(nodes: readonly StrNode[]): ContextNodeDisplay<string | undefined> {\r\n    const first = nodes.find(node => this.computeNode(node).value !== undefined)\r\n    return first ? this.computeNode(first) : illformedStr\r\n  }\r\n  private _small(nodes: readonly StrNode[]): ContextNodeDisplay<string | undefined> {\r\n    let smallest: ContextNodeDisplay<string | undefined> | undefined = undefined\r\n    for (const node of nodes) {\r\n      const candidate = this.computeNode(node)\r\n      if (smallest?.value === undefined || (candidate.value && candidate.value < smallest.value))\r\n        smallest = candidate\r\n    }\r\n    return smallest ?? illformedStr\r\n  }\r\n  private _read(node: ReadNode<number | string | undefined>): ContextNodeDisplay<number | string | undefined> {\r\n    const { path } = node\r\n    if (node.accu === undefined) {\r\n      return this.readFirst(path) ?? (node.type === \"string\" ? illformedStr : illformed)\r\n    } else {\r\n      const nodes = this.prereadAll(path)\r\n      if (nodes.length === 1) return this.computeNode(nodes[0])\r\n      return node.accu === \"small\"\r\n        ? this._small(nodes as StrNode[])\r\n        : this._accumulate(node.accu, nodes.map(x => this.computeNode(x)) as ContextNodeDisplay[])\r\n    }\r\n  }\r\n  private _lookup(node: LookupNode<NumNode | StrNode>): ContextNodeDisplay<number | string | undefined> {\r\n    const key = this.computeNode(node.operands[0]).value\r\n    const selected = node.table[key!] ?? node.operands[1]\r\n    if (!selected)\r\n      throw new Error(`Lookup Fail with key ${key}`)\r\n    return this.computeNode(selected)\r\n  }\r\n  private _match(node: MatchNode<StrNode | NumNode, StrNode | NumNode>): ContextNodeDisplay<number | string | undefined> {\r\n    const [v1Node, v2Node, matchNode, unmatchNode] = node.operands\r\n    const v1 = this.computeNode(v1Node), v2 = this.computeNode(v2Node)\r\n    const matching = v1.value === v2.value\r\n    let result = this.computeNode(matching ? matchNode : unmatchNode)\r\n    return ((matching && node.emptyOn === \"match\") || (!matching && node.emptyOn === \"unmatch\"))\r\n      ? makeEmpty(result.value) : result\r\n  }\r\n  private _threshold(node: ThresholdNode<NumNode | StrNode>): ContextNodeDisplay<number | string | undefined> {\r\n    const [valueNode, thresholdNode, pass, fail] = node.operands\r\n    const value = this.computeNode(valueNode), threshold = this.computeNode(thresholdNode)\r\n    const result = value.value >= threshold.value ? this.computeNode(pass) : this.computeNode(fail)\r\n    return (value.value >= threshold.value)\r\n      ? (node.emptyOn === \"ge\" ? makeEmpty(result.value) : result)\r\n      : (node.emptyOn === \"l\" ? makeEmpty(result.value) : result)\r\n  }\r\n  private _data(node: DataNode<NumNode | StrNode>): ContextNodeDisplay<number | string | undefined> {\r\n    let child = this.children.get(node.data)\r\n    if (!child) {\r\n      child = new UIData(node.data, node.reset ? this.origin : this)\r\n      this.children.set(node.data, child)\r\n    }\r\n    return child.computeNode(node.operands[0])\r\n  }\r\n  private _compute(node: ComputeNode): ContextNodeDisplay {\r\n    const { operation, operands } = node\r\n    return this._accumulate(operation, operands.map(x => this.computeNode(x)))\r\n  }\r\n  private _subscript(node: SubscriptNode<number>): ContextNodeDisplay {\r\n    const operand = this.computeNode(node.operands[0])\r\n    const value = node.list[operand.value] ?? NaN\r\n    return this._constant(value)\r\n  }\r\n  private _constant<V>(value: V): ContextNodeDisplay<V> {\r\n    return {\r\n      info: {}, value,\r\n      empty: false,\r\n      mayNeedWrapping: false,\r\n      dependencies: new Set(),\r\n    }\r\n  }\r\n  private _accumulate(operation: ComputeNode[\"operation\"], operands: ContextNodeDisplay[]): ContextNodeDisplay {\r\n    let variant: Variant | undefined\r\n    switch (operation) {\r\n      case \"add\": case \"mul\": case \"min\": case \"max\":\r\n      case \"res\": case \"sum_frac\":\r\n        variant = mergeVariants(operands); break\r\n      default: assertUnreachable(operation)\r\n    }\r\n    switch (operation) {\r\n      case \"add\": case \"mul\": case \"min\": case \"max\":\r\n        const identity = allOperations[operation]([])\r\n        if (process.env.NODE_ENV !== \"development\")\r\n          operands = operands.filter(operand => operand.value !== identity)\r\n        if (!operands.length)\r\n          return variant ? { ...this._constant(identity), info: { variant } } : this._constant(identity)\r\n    }\r\n\r\n    let formula: { display: Displayable, dependencies: Displayable[] }\r\n    let mayNeedWrapping = false\r\n    switch (operation) {\r\n      case \"max\": formula = fStr`Max( ${{ operands }} )`; break\r\n      case \"min\": formula = fStr`Min( ${{ operands }} )`; break\r\n      case \"add\": formula = fStr`${{ operands, separator: ' + ' }}`; break\r\n      case \"mul\": formula = fStr`${{ operands, separator: ' * ', shouldWrap: operands.length > 1 }}`; break\r\n      case \"sum_frac\": formula = fStr`${{ operands: [operands[0]], shouldWrap }} / ( ${{ operands, separator: ' + ' }} )`; break\r\n      case \"res\": {\r\n        const base = operands[0].value\r\n        if (base < 0) {\r\n          formula = fStr`100% - ${{ operands, shouldWrap }} / 2`\r\n          mayNeedWrapping = true\r\n        }\r\n        else if (base >= 0.75) formula = fStr`100% / ( ${{ operands, shouldWrap }} * 4 + 100% )`\r\n        else {\r\n          formula = fStr`100% - ${{ operands, shouldWrap }}`\r\n          mayNeedWrapping = true\r\n        }\r\n        break\r\n      }\r\n      default: assertUnreachable(operation)\r\n    }\r\n    switch (operation) {\r\n      case \"add\": case \"mul\":\r\n        if (operands.length <= 1) mayNeedWrapping = operands[0]?.mayNeedWrapping ?? true\r\n        else if (operation === \"add\") mayNeedWrapping = true\r\n    }\r\n\r\n    const value = allOperations[operation](operands.map(x => x.value))\r\n    const dependencies = new Set([...operands.flatMap(x =>\r\n      x.info.pivot && x.assignment\r\n        ? [x.assignment, ...x.dependencies]\r\n        : [...x.dependencies])])\r\n    const result: ContextNodeDisplay = {\r\n      info: { variant },\r\n      formula: formula.display,\r\n      empty: operands.every(x => x.empty),\r\n      value, mayNeedWrapping, dependencies,\r\n    }\r\n    return result\r\n  }\r\n}\r\ntype ContextNodeDisplayList = { operands: ContextNodeDisplay[], separator?: string, shouldWrap?: boolean }\r\nfunction fStr(strings: TemplateStringsArray, ...list: ContextNodeDisplayList[]): { display: Displayable, dependencies: Displayable[] } {\r\n  const dependencies = new Set<Displayable>()\r\n  const predisplay: Displayable[] = []\r\n\r\n  strings.forEach((string, i) => {\r\n    predisplay.push(string)\r\n\r\n    const key = list[i]\r\n    if (key) {\r\n      const { operands, shouldWrap, separator = \", \" } = key\r\n      operands.forEach((item, i, array) => {\r\n        let itemFormula: Displayable\r\n        if (!item.info.pivot && item.formula) itemFormula = item.formula\r\n        else itemFormula = createFormulaComponent(item)\r\n\r\n        if (shouldWrap && item.mayNeedWrapping) {\r\n          predisplay.push(\"( \")\r\n          predisplay.push(itemFormula)\r\n          predisplay.push(\" )\")\r\n        } else {\r\n          predisplay.push(itemFormula)\r\n        }\r\n        if (i + 1 < array.length) predisplay.push(separator)\r\n        item.dependencies.forEach(x => dependencies.add(x))\r\n      })\r\n    }\r\n  })\r\n  return { display: mergeFormulaComponents(predisplay), dependencies: [...dependencies] }\r\n}\r\nfunction mergeVariants<V>(operands: ContextNodeDisplay<V>[]): Info[\"variant\"] {\r\n  const unique = new Set(operands.map(x => x.info.variant))\r\n  if (unique.size > 1) unique.delete(undefined)\r\n  if (unique.size > 1) unique.delete(\"physical\")\r\n  // Prefer reactions\r\n  if (unique.has(\"melt\")) return \"melt\"\r\n  if (unique.has(\"vaporize\")) return \"vaporize\"\r\n  return unique.values().next().value\r\n}\r\nfunction computeNodeDisplay<V>(node: ContextNodeDisplay<V>): NodeDisplay<V> {\r\n  const { info, dependencies, value, formula, assignment, empty } = node\r\n  return {\r\n    operation: true,\r\n    info,\r\n    value,\r\n    isEmpty: empty,\r\n    unit: KeyMap.unit(info.key),\r\n    formula, formulas: [...(assignment ? [assignment] : []), ...dependencies]\r\n  }\r\n}\r\n\r\n//* Comment/uncomment this line to toggle between string formulas and JSX formulas\r\nfunction createDisplay(node: ContextNodeDisplay<number | string | undefined>) {\r\n  const { info, value, formula } = node\r\n  const { key, prefix, source, variant, fixed } = info\r\n  if (typeof value !== \"number\") return\r\n  node.valueDisplay = <ColorText color=\"info\">{valueString(value, KeyMap.unit(key), fixed)}</ColorText>\r\n  if (key && key !== '_') {\r\n    const prefixDisplay = (prefix && !source) ? <>{KeyMap.getPrefixStr(prefix)} </> : <></>\r\n    // TODO: Convert `source` key to actual name\r\n    const sourceDisplay = source ? <ColorText color=\"secondary\"> ({source})</ColorText> : null\r\n    node.name = <><ColorText color={variant}>{prefixDisplay}{KeyMap.get(key!)}</ColorText>{sourceDisplay}</>\r\n\r\n    if (formula)\r\n      node.assignment = <div id=\"formula\">{node.name} {node.valueDisplay} = {formula}</div>\r\n  }\r\n}\r\nfunction createFormulaComponent(node: ContextNodeDisplay): Displayable {\r\n  const { name, valueDisplay } = node\r\n  //TODO: change formula size in the formula display element instead\r\n  return name ? <><span style={{ fontSize: \"85%\" }}>{name}</span> {valueDisplay}</> : valueDisplay!\r\n}\r\nfunction mergeFormulaComponents(components: Displayable[]): Displayable {\r\n  return <>{components.map((x, i) => <span key={i}>{x}</span>)}</>\r\n}\r\n/*/\r\nfunction createDisplay(node: ContextNodeDisplay<number | string | undefined>) {\r\n  const { info, value, formula } = node\r\n  const { key, prefix, source, fixed } = info\r\n  if (typeof value !== \"number\") return\r\n  node.valueDisplay = valueString(value, KeyMap.unit(key), fixed)\r\n  if (key && key !== '_') {\r\n    const prefixDisplay = (prefix && !source) ? `${KeyMap.getPrefixStr(prefix)} ` : \"\"\r\n    // TODO: Convert `source` key to actual name\r\n    const sourceDisplay = source ? ` ${source}` : \"\"\r\n    node.name = `${prefixDisplay}${KeyMap.getStr(key!)}${sourceDisplay}`\r\n\r\n    if (formula)\r\n      node.assignment = `${node.name} ${node.valueDisplay} = ${formula}`\r\n  }\r\n}\r\nfunction createFormulaComponent(node: ContextNodeDisplay): Displayable {\r\n  const { name, valueDisplay } = node\r\n  return name ? `${name} ${valueDisplay}` : valueDisplay!\r\n}\r\nfunction mergeFormulaComponents(components: Displayable[]): Displayable {\r\n  return (components as string[]).join(\"\")\r\n}\r\n//*/\r\n\r\nfunction mergeInfo(base: Info, override: Info): Info {\r\n  const result = { ...base }\r\n  for (const [key, value] of Object.entries(override))\r\n    if (value) result[key] = value as any\r\n  return result\r\n}\r\n\r\ninterface ContextNodeDisplay<V = number> {\r\n  info: Info\r\n  empty: boolean\r\n  value: V\r\n\r\n  dependencies: Set<Displayable>\r\n\r\n  mayNeedWrapping: boolean // Whether this formula should be parenthesized when it is a part of multiplications/divisions and subtractions' subtrahends\r\n\r\n  // Don't set these manually outside of `UIData.computeNode`\r\n  name?: Displayable\r\n  valueDisplay?: Displayable\r\n  formula?: Displayable\r\n  assignment?: Displayable\r\n}\r\n\r\nconst illformed: ContextNodeDisplay = {\r\n  info: { pivot: true },\r\n  value: NaN,\r\n  empty: false,\r\n  dependencies: new Set(),\r\n  mayNeedWrapping: false\r\n}\r\nconst illformedStr: ContextNodeDisplay<string | undefined> = {\r\n  info: { pivot: true },\r\n  value: undefined,\r\n  empty: false,\r\n  dependencies: new Set(),\r\n  mayNeedWrapping: false\r\n}\r\nfunction makeEmpty(emptyValue: number): ContextNodeDisplay<number>\r\nfunction makeEmpty(emptyValue: string | undefined): ContextNodeDisplay<string | undefined>\r\nfunction makeEmpty(emptyValue: number | string | undefined): ContextNodeDisplay<number | string | undefined>\r\nfunction makeEmpty(emptyValue: number | string | undefined): ContextNodeDisplay<number | string | undefined> {\r\n  return {\r\n    info: {}, value: emptyValue, empty: true, dependencies: new Set(), mayNeedWrapping: false\r\n  }\r\n}\r\n","\r\nimport { objectKeyMap } from \"../Util/Util\"\r\nimport type { AnyNode, Data, DataNode, Info, LookupNode, MatchNode, NumNode, ReadNode, StrNode, SubscriptNode } from \"./type\"\r\n\r\ntype Num = number | NumNode\r\ntype Str = string | undefined | StrNode\r\ntype Any = Num | Str\r\n\r\nexport const todo: NumNode = constant(NaN, { key: \"TODO\" })\r\nexport const one = percent(1), naught = percent(0)\r\n\r\nexport function constant(value: number, info?: Info): NumNode\r\nexport function constant(value: string | undefined, info?: Info): StrNode\r\nexport function constant(value: number | string | undefined, info?: Info): AnyNode\r\nexport function constant(value: number | string | undefined, info?: Info): AnyNode {\r\n  return { operation: \"const\", operands: [], value, info }\r\n}\r\n/** `value` in percentage. The value is written as non-percentage, e.g., `percent(1)` for 100% */\r\nexport function percent(value: number, info?: Info): NumNode {\r\n  if (value >= Number.MAX_VALUE / 100) value = Infinity\r\n  if (value <= -Number.MAX_VALUE / 100) value = -Infinity\r\n  return constant(value, { key: \"_\", ...info })\r\n}\r\n/** Inject `info` to the node in-place */\r\nexport function infoMut(node: NumNode, info: Info): NumNode\r\nexport function infoMut(node: StrNode, info: Info): StrNode\r\nexport function infoMut(node: NumNode | StrNode, info: Info): NumNode | StrNode {\r\n  if (info) node.info = { ...node.info, ...info }\r\n  return node\r\n}\r\n\r\n/** `table[string] ?? defaultNode` */\r\nexport function lookup(index: StrNode, table: Dict<string, NumNode>, defaultV: Num | \"none\", info?: Info): NumNode\r\nexport function lookup(index: StrNode, table: Dict<string, StrNode>, defaultV: Str | \"none\", info?: Info): StrNode\r\nexport function lookup(index: StrNode, table: Dict<string, AnyNode>, defaultV: Any | \"none\", info?: Info): LookupNode<any> {\r\n  const operands = defaultV !== \"none\" ? [intoV(index), intoV(defaultV)] as const : [intoV(index)] as const\r\n  return { operation: \"lookup\", operands, table, info }\r\n}\r\n\r\n/** min( x1, x2, ... ) */\r\nexport function min(...values: Num[]): NumNode {\r\n  return { operation: \"min\", operands: intoOps(values) }\r\n}\r\n/** max( x1, x2, ... ) */\r\nexport function max(...values: Num[]): NumNode {\r\n  return { operation: \"max\", operands: intoOps(values) }\r\n}\r\n/** x1 + x2 + ... */\r\nexport function sum(...values: Num[]): NumNode {\r\n  return { operation: \"add\", operands: intoOps(values) }\r\n}\r\n/** x1 * x2 * ... */\r\nexport function prod(...values: Num[]): NumNode {\r\n  return { operation: \"mul\", operands: intoOps(values) }\r\n}\r\n/** x / (x + c) */\r\nexport function frac(x: Num, c: Num): NumNode {\r\n  return { operation: \"sum_frac\", operands: intoOps([x, c]) }\r\n}\r\nexport function res(base: Num): NumNode {\r\n  return { operation: \"res\", operands: intoOps([base]) }\r\n}\r\n\r\n/** v1 == v2 ? pass : 0 */\r\nexport function equal(v1: Num, v2: Num, pass: Num, info?: Info): MatchNode<NumNode, NumNode>\r\nexport function equal(v1: Str, v2: Str, pass: Num, info?: Info): MatchNode<NumNode, NumNode>\r\nexport function equal(v1: Num | Str, v2: Num | Str, pass: Num, info?: Info): MatchNode<NumNode | StrNode, NumNode | StrNode> {\r\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(pass), intoV(0)], info, emptyOn: \"unmatch\" }\r\n}\r\n/** v1 == v2 ? pass : `undefined` */\r\nexport function equalStr(v1: Num, v2: Num, pass: Str, info?: Info): MatchNode<StrNode, NumNode>\r\nexport function equalStr(v1: Str, v2: Str, pass: Str, info?: Info): MatchNode<StrNode, NumNode>\r\nexport function equalStr(v1: Num | Str, v2: Num | Str, pass: Str, info?: Info): MatchNode<StrNode, NumNode | StrNode> {\r\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(pass), intoV(undefined)], info, emptyOn: \"unmatch\" }\r\n}\r\n/** v1 != v2 ? pass : 0 */\r\nexport function unequal(v1: Num, v2: Num, pass: Num, info?: Info): MatchNode<NumNode, NumNode>\r\nexport function unequal(v1: Str, v2: Str, pass: Num, info?: Info): MatchNode<NumNode, NumNode>\r\nexport function unequal(v1: Num | Str, v2: Num | Str, pass: Num | Str, info?: Info): MatchNode<NumNode | StrNode, NumNode | StrNode> {\r\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(0), intoV(pass)], info, emptyOn: \"match\" }\r\n}\r\n/** v1 >= v2 ? pass : 0 */\r\nexport function greaterEq(v1: Num, v2: Num, pass: Num, info?: Info): NumNode\r\nexport function greaterEq(v1: Num, v2: Num, pass: Num, info?: Info): NumNode {\r\n  const operands = [intoV(v1), intoV(v2), intoV(pass), intoV(0)] as any\r\n  return { operation: \"threshold\", operands, info, emptyOn: \"l\" }\r\n}\r\n/** v1 >= v2 ? pass : `undefined` */\r\nexport function greaterEqStr(v1: Num, v2: Num, pass: Str, info?: Info): StrNode\r\nexport function greaterEqStr(v1: Num, v2: Num, pass: Str, info?: Info): NumNode | StrNode {\r\n  const operands = [intoV(v1), intoV(v2), intoV(pass), intoV(undefined)] as any\r\n  return { operation: \"threshold\", operands, info, emptyOn: \"l\" }\r\n}\r\n/** v1 < v2 ? pass : 0 */\r\nexport function lessThan(v1: Num, v2: Num, pass: Num, info?: Info): NumNode\r\nexport function lessThan(v1: Num, v2: Num, pass: Num | Str, info?: Info): NumNode | StrNode {\r\n  const operands = [intoV(v1), intoV(v2), intoV(0), intoV(pass)] as any\r\n  return { operation: \"threshold\", operands, info, emptyOn: \"ge\" }\r\n}\r\n\r\nexport function setReadNodeKeys<T extends NodeList>(nodeList: T, prefix: string[] = []): T {\r\n  if (nodeList.operation) {\r\n    if (nodeList.operation !== \"read\")\r\n      throw new Error(`Found ${(nodeList as any).operation} node while making reader`)\r\n    return { ...nodeList, path: prefix }\r\n  } else {\r\n    return objectKeyMap(Object.keys(nodeList), key =>\r\n      setReadNodeKeys(nodeList[key], [...prefix, key])) as any\r\n  }\r\n}\r\nexport function data(base: NumNode, data: Data): DataNode<NumNode>\r\nexport function data(base: StrNode, data: Data): DataNode<StrNode>\r\nexport function data(base: NumNode | StrNode, data: Data): DataNode<NumNode> | DataNode<StrNode>\r\nexport function data(base: AnyNode, data: Data): DataNode<AnyNode> {\r\n  return { operation: \"data\", operands: [base], data }\r\n}\r\nexport function resetData(base: NumNode, data: Data, info?: Info): NumNode\r\nexport function resetData(base: StrNode, data: Data, info?: Info): StrNode\r\nexport function resetData(base: NumNode | StrNode, data: Data, info?: Info): DataNode<NumNode | StrNode>\r\nexport function resetData(base: AnyNode, data: Data, info?: Info): DataNode<any> {\r\n  return { operation: \"data\", operands: [base], data, reset: true, info }\r\n}\r\n\r\n\r\nexport function customRead(path: readonly string[], info?: Info): ReadNode<number> {\r\n  return { operation: \"read\", operands: [], path, info, type: \"number\" }\r\n}\r\nexport function customStringRead(path: readonly string[]): ReadNode<string> {\r\n  return { operation: \"read\", operands: [], path, type: \"string\" }\r\n}\r\nexport function read(accu?: ReadNode<number>[\"accu\"], info?: Info): ReadNode<number> {\r\n  return { operation: \"read\", operands: [], path: [], accu, info, type: \"number\" }\r\n}\r\n/**\r\n * CAUTION: Use `prio` accumulation sparingly. WR don't assume the reading order, so the result may be unstable\r\n */\r\nexport function stringRead(accu?: ReadNode<string | undefined>[\"accu\"]): ReadNode<string | undefined> {\r\n  return { operation: \"read\", operands: [], path: [], accu, type: \"string\" }\r\n}\r\nexport function stringPrio(...operands: Str[]): StrNode {\r\n  return { operation: \"prio\", operands: intoOps(operands) }\r\n}\r\n/** list[index] */\r\nexport function subscript<V>(index: NumNode, list: V[], info?: Info): SubscriptNode<V> {\r\n  return { operation: \"subscript\", operands: [index], list, info }\r\n}\r\n\r\nfunction intoOps(values: Num[]): NumNode[]\r\nfunction intoOps(values: Str[]): StrNode[]\r\nfunction intoOps(values: Any[]): AnyNode[]\r\nfunction intoOps(values: Any[]): AnyNode[] {\r\n  return values.map(value => typeof value === \"object\" ? value : constant(value))\r\n}\r\nfunction intoV(value: Num): NumNode\r\nfunction intoV(value: Str): StrNode\r\nfunction intoV(value: Num | Str): NumNode | StrNode\r\nfunction intoV(value: Any): AnyNode {\r\n  return (typeof value !== \"object\") ? constant(value) : value\r\n}\r\n\r\ntype _NodeList = {\r\n  [key: string]: NodeList\r\n} & {\r\n  operation?: never\r\n}\r\ntype NodeList = _NodeList | ReadNode<number> | ReadNode<string>\r\n\r\n/**\r\n * `v1` === `v2` ? `match` : `unmatch`\r\n * @deprecated Use `equal`, `unequal`, or `equalStr` instead\r\n */\r\nexport function matchFull(v1: Num, v2: Num, match: Num, unmatch: Num, info?: Info): MatchNode<NumNode, NumNode>\r\nexport function matchFull(v1: Num, v2: Num, match: Str, unmatch: Str, info?: Info): MatchNode<StrNode, NumNode>\r\nexport function matchFull(v1: Str, v2: Str, match: Num, unmatch: Num, info?: Info): MatchNode<NumNode, StrNode>\r\nexport function matchFull(v1: Str, v2: Str, match: Str, unmatch: Str, info?: Info): MatchNode<StrNode, StrNode>\r\nexport function matchFull(v1: Num | Str, v2: Num | Str, match: Num | Str, unmatch: Num | Str, info?: Info): MatchNode<NumNode | StrNode, NumNode | StrNode> {\r\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(match), intoV(unmatch)], info }\r\n}\r\n","import { useCallback, useContext, useEffect, useState } from \"react\";\r\nimport { DatabaseContext } from \"../Database/Database\";\r\n\r\nexport default function useDBState<O extends object>(key: string, init: () => O): [O, (value: Partial<O>) => void] {\r\n  const { database } = useContext(DatabaseContext)\r\n  const [state, setState] = useState(() => database.states.getWithInit<O>(key, init))\r\n\r\n  useEffect(() =>\r\n    key ? database.states.follow(key, setState as any) : undefined,\r\n    [key, setState, database])\r\n  useEffect(() => setState(database.states.getWithInit<O>(key, init)), [database, init, key])\r\n  const updateState = useCallback(\r\n    value => database.states.set(key, value),\r\n    [database, key],\r\n  )\r\n\r\n  return [state ?? init(), updateState]\r\n}\r\n","import { useCallback, useState } from \"react\"\r\n\r\nexport default function useForceUpdate(): [object, () => void] {\r\n  const [stateDirty, update] = useState({})\r\n  const forceUpdateHook = useCallback(() => update({}), [])\r\n  return [stateDirty, forceUpdateHook]\r\n}","import { useMediaQuery, useTheme } from \"@mui/material\";\r\n\r\nexport default function useMediaQueryUp() {\r\n  const theme = useTheme();\r\n  const sm = useMediaQuery(theme.breakpoints.up('sm'));\r\n  const md = useMediaQuery(theme.breakpoints.up('md'));\r\n  const lg = useMediaQuery(theme.breakpoints.up('lg'));\r\n  const xl = useMediaQuery(theme.breakpoints.up('xl'));\r\n  if (xl) return \"xl\"\r\n  if (lg) return \"lg\"\r\n  if (md) return \"md\"\r\n  if (sm) return \"sm\"\r\n  return \"xs\"\r\n}\r\n","import { useEffect, useState } from \"react\";\r\n/**\r\n *\r\n * @param promiseFunc\r\n * @param dependencies - Reloads the promise when any of the dependencies are changed. (Using useEffect dependency)\r\n * @param useOld - When the promises are updated, then there is a period of time before the new promise return. useOld uses the previous value without a undefined gap.\r\n * @returns\r\n */\r\nexport default function usePromise<T>(promiseFunc: () => Promise<T> | undefined, dependencies: any[], useOld = true): T | undefined {\r\n  const [res, setRes] = useState<T | undefined>(undefined);\r\n  useEffect(() => {\r\n    let pending = true\r\n    promiseFunc()?.then(res => pending && setRes(res), console.error) ?? setRes(undefined)\r\n    return () => {\r\n      pending = false\r\n      !useOld && setRes(undefined)\r\n    }\r\n  }, dependencies)// eslint-disable-line react-hooks/exhaustive-deps\r\n  return res\r\n}\r\n","import CharacterSheet from \"../Data/Characters/CharacterSheet\";\r\nimport { ArtCharDatabase } from \"../Database/Database\";\r\nimport i18n from \"../i18n\";\r\nimport { CharacterKey } from \"../Types/consts\";\r\nimport { FilterConfigs, SortConfigs } from \"./SortByFilters\";\r\nexport const characterSortKeys = [\"level\", \"rarity\", \"name\"]\r\nexport type CharacterSortKey = typeof characterSortKeys[number]\r\n\r\nexport function characterSortConfigs(database: ArtCharDatabase, characterSheets: Record<CharacterKey, CharacterSheet>): SortConfigs<CharacterSortKey, CharacterKey> {\r\n  return {\r\n    new: {\r\n      getValue: (ck) => database.chars.get(ck as CharacterKey) ? 0 : 1,\r\n      tieBreaker: \"name\"\r\n    },\r\n    name: {\r\n      getValue: (ck) => i18n.t(`charNames_gen\"${ck}`).toString(),\r\n    },\r\n    level: {\r\n      getValue: (ck) => {\r\n        const char = database.chars.get(ck as CharacterKey)\r\n        if (!char) return 0\r\n        return char.level * char.ascension\r\n      },\r\n      tieBreaker: \"rarity\"\r\n    },\r\n    rarity: {\r\n      getValue: (ck) => characterSheets?.[ck]?.rarity,\r\n      tieBreaker: \"level\"\r\n    }\r\n  }\r\n}\r\n\r\nexport type CharacterFilterConfigs = FilterConfigs<\"element\" | \"weaponType\" | \"favorite\" | \"name\", CharacterKey>\r\nexport function characterFilterConfigs(database: ArtCharDatabase, characterSheets: Record<CharacterKey, CharacterSheet>): CharacterFilterConfigs {\r\n  return {\r\n    element: (ck, filter) => filter.includes(characterSheets?.[ck]?.elementKey) ||\r\n      (ck === \"Traveler\" && !database.chars.get(ck as CharacterKey) && filter.some(fe => characterSheets.Traveler.elementKeys.includes(fe))) ||\r\n      (ck === \"Traveler\" && filter.includes(database.chars.get(ck as CharacterKey)?.elementKey)),\r\n    weaponType: (ck, filter) => filter.includes(characterSheets?.[ck]?.weaponTypeKey),\r\n    favorite: (ck, filter) =>\r\n      !filter || (filter === (database.chars.get(ck as CharacterKey)?.favorite ? \"yes\" : \"no\")),\r\n    name: (ck, filter) => !filter || (i18n.t(`charNames_gen:${ck}`).toLowerCase().includes(filter.toLowerCase()))\r\n  }\r\n}\r\n","type SortConfig<T> = {\r\n  getValue: (id: T) => number | string\r\n  tieBreaker?: string\r\n}\r\nexport type SortConfigs<Keys extends string, T> = Record<Keys, SortConfig<T>>\r\n\r\nexport function sortFunction<Keys extends string, T>(sortby: string, ascending: boolean, configs: SortConfigs<Keys, T>) {\r\n  function Sort(a: T, b: T, ascending: boolean, config: SortConfig<T>) {\r\n    const aV = config.getValue(a)\r\n    const bV = config.getValue(b)\r\n    let diff = 0\r\n    if (typeof aV === \"string\" && typeof bV === \"string\")\r\n      diff = aV.localeCompare(bV)\r\n    else\r\n      diff = ((bV as number) - (aV as number))\r\n    return (ascending ? -1 : 1) * diff\r\n  }\r\n  return (a: T, b: T) => {\r\n    if (!configs[sortby]) return 0\r\n    const filterOption = configs[sortby]\r\n    let diff = Sort(a, b, ascending, filterOption)\r\n    if (!diff && filterOption.tieBreaker && configs[filterOption.tieBreaker])\r\n      diff = Sort(a, b, ascending, configs[filterOption.tieBreaker])\r\n    return diff\r\n  }\r\n}\r\n\r\ntype FilterConfig<T> = (obj: T, filter: any) => boolean\r\nexport type FilterConfigs<Keys extends string, T> = Record<Keys, FilterConfig<T>>\r\nexport function filterFunction<Keys extends string, T>(filterOptions: Record<Keys, any>, filterConfigs: FilterConfigs<Keys, T>) {\r\n  return (obj: T) => Object.entries(filterOptions).every(([optionKey, optionVal]) => filterConfigs[optionKey as any] && filterConfigs[optionKey as any](obj, optionVal))\r\n}\r\n"],"names":["weaponTypes","bow","catalyst","claymore","polearm","sword","slot","flower","plume","sands","goblet","circlet","resin","fragile","condensed","exp_books","advice","wit","experience","team","team1","team2","team3","team4","CardDark","styled","Card","backgroundColor","theme","palette","contentDark","main","CardLight","contentLight","CloseButton","large","props","t","useTranslation","color","startIcon","sx","p","minWidth","ConditionalWrapper","condition","wrapper","falseWrapper","children","DropdownButton","title","id","useState","anchorEl","setAnchorEl","open","Boolean","handleClick","useCallback","event","currentTarget","handleClose","Suspense","fallback","endIcon","width","undefined","onClick","onClose","MenuListProps","height","ImgIcon","name","size","display","verticalAlign","ScrollModal","Modal","overflow","paddingTop","spacing","paddingBottom","ModalContainer","Container","padding","minHeight","flexDirection","justifyContent","pointerEvents","ModalWrapper","containerProps","variant","SolidToggleButtonGroup","ToggleButtonGroup","shouldForwardProp","prop","baseColor","selectedColor","contrastText","dark","transition","SortByButton","sortKeys","value","onChange","ascending","onChangeAsc","alignItems","gap","i18nKey","map","key","selected","disabled","icon","faSortAmountDownAlt","faSortAmountUp","className","StarIcon","faStar","Stars","stars","colored","component","Array","keys","_","i","uncoloredEleIcons","anemo","faAnemo","geo","faGeo","electro","faElectro","hydro","faHydro","pyro","faPyro","cryo","faCryo","dendro","faDendro","physical","faPhysicalDmgBonus","coloredEleIcon","objectKeyMap","Object","lineHeight","StatIcon","hp_","faHp","hp","atk_","faAtk","atk","def_","faDef","def","eleMas","faElementalMastery","critRate_","faCritRate","critDMG_","faCritDmg","enerRech_","faEnergyRecharge","incHeal_","faHealingAdd","heal_","faHealingBonus","cdRed_","faCdReduction","shield_","faShieldStrength","stamina","faMaxStamina","fromEntries","flatMap","ele","characterSheets","then","imp","default","CharacterSheet","charSheet","data","sheet","isMelee","weaponTypeKey","getData","getTalent","eleKey","talent","talents","getTalentOfKey","talentKey","sheets","this","src","thumbImgSide","marginTop","marginLeft","cardImg","thumbImg","bannerImg","rarity","elementKey","constellationName","get","charKey","c","getLevelString","level","ascension","ascensionMaxLevel","talentHeader","tr","img","m","action","st","description","canShowTalentsNodes","greaterEq","input","canShowTemplate","canShow","includes","compareVal","val","slice","charTemplates","cKey","wKey","assets","travelerEle","ns","key18","trans","auto","Assets","talentTemplate","docSections","sections","text","headerTemplate","partialSection","header","fieldsTemplate","partialFields","conditionalTemplate","partialCond","strKey","values","sgt","condReadNode","path","customStringRead","cond","subKey","typeKey","inferInfoMut","source","crawlObject","x","operation","info","isTeamBuff","reference","objPathValue","prefix","console","error","dataObjForArtifact","art","mainStatAssumptionLevel","mainStatVal","Artifact","mainStatKey","Math","max","min","stats","push","substats","forEach","accurateValue","endsWith","percent","constant","slotKey","set","setKey","artSet","dataObjForCharacter","char","result","lvl","constellation","asc","infusion","infusionAura","premod","skill","burst","enemy","allElementsWithPhy","enemyOverride","enemyLevel","hit","hitMode","reaction","reactionMode","customBonus","entries","bonusStats","enemyDefRed_","enemyDefIgn_","defIgn","conditional","layeredAssignment","dataObjForWeapon","weapon","refinement","refineIndex","teamBuff","setReadNodeKeys","deepClone","uiDataForTeam","teamData","activeCharKey","mergedData","mergeData","targetRef","buffs","calcs","customReadNodes","getReadNode","base","custom","newNode","customRead","accu","sourceKey","sourceBuff","buff","calc","asConst","resetData","readNode","targetKey","pivot","assign","origin","UIData","target","length","internal","type","errMsg","operands","Set","filter","computeUIData","allElements","allTalents","allMoves","allArtModStats","allTransformative","allAmplifying","allModStats","allNonModStats","allEleEnemyResKeys","read","allModStatNodes","allNonModStatNodes","withDefaultInfo","stringRead","charEle","weaponType","special","overridableSelf","nonOverridableSelf","bonus","total","objectKeyValueMap","cappedCritRate","allSlotKeys","allArtifactSets","sub","sub2","defRed","move","dmgBonus","dmgInc","dmg","stat","baseAmpBonus","sum","one","prod","frac","effectiveReaction","lookup","pyro_vaporize","pyro_melt","equalStr","common","naught","all_dmg_","all_dmgInc","element","NaN","critHit","avgHit","melt","melt_dmg_","vaporize","vaporize_dmg_","res","infoMut","tally","allRegions","todo","uiInput","forEachNodes","formulas","topDown","bottomUp","visiting","visited","traverse","formula","has","add","delete","mapFormulas","topDownMap","bottomUpMap","topDownMapped","Map","bottomUpMapped","check","arrayEqual","a","b","every","allCommutativeMonoidOperations","reduce","mul","allOperations","sum_frac","threshold","pass","fail","commutativeMonoidOperationSet","optimize","topLevelData","shouldFold","_formula","deduplicate","flatten","constantFold","f","flattened","dep","elementCounts","array","wrap","counts","next","factored","count","fill","candidatesByOperation","remainingCounts","currentCounts","commonCounts","nextCounts","dependency","currentCount","commonCount","candidates","candidate","candidateCounts","candidateCount","clear","processed","nextContextMap","fold","context","old","numericOperands","formulaOperands","folded","numericValue","isFinite","index","table","Error","first","find","op","smallest","v1","v2","match","unmatch","list","reset","nextContext","assertUnreachable","shouldWrap","parent","nodes","getAll","calculated","node","trace","isEmpty","unit","dependencies","assignment","empty","KeyMap","computeNodeDisplay","computeNode","_compute","_threshold","_constant","_subscript","_read","_data","_match","_lookup","_prio","_small","override","mergeInfo","mayNeedWrapping","fixed","valueDisplay","valueString","prefixDisplay","sourceDisplay","createDisplay","illformedStr","readFirst","illformed","prereadAll","_accumulate","v1Node","v2Node","matchNode","unmatchNode","matching","emptyOn","makeEmpty","valueNode","thresholdNode","child","operand","unique","mergeVariants","identity","fStr","separator","strings","predisplay","string","item","itemFormula","createFormulaComponent","mergeFormulaComponents","style","fontSize","components","emptyValue","Number","MAX_VALUE","Infinity","defaultV","intoV","intoOps","equal","unequal","greaterEqStr","lessThan","nodeList","stringPrio","subscript","matchFull","useDBState","init","database","useContext","DatabaseContext","states","getWithInit","state","setState","useEffect","follow","updateState","useForceUpdate","stateDirty","update","useMediaQueryUp","useTheme","sm","useMediaQuery","breakpoints","up","md","lg","usePromise","promiseFunc","useOld","setRes","pending","characterSortKeys","characterSortConfigs","new","getValue","ck","chars","tieBreaker","i18n","toString","characterFilterConfigs","some","fe","Traveler","elementKeys","favorite","toLowerCase","sortFunction","sortby","configs","Sort","config","aV","bV","localeCompare","filterOption","diff","filterFunction","filterOptions","filterConfigs","obj","optionKey","optionVal"],"sourceRoot":""}